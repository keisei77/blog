{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/javascript-visualized-prototypal-inheritance/","result":{"data":{"site":{"siteMetadata":{"title":"学习随笔"}},"markdownRemark":{"id":"08b94b19-1561-54d4-8262-4c38219c4d98","excerpt":"当我们对字符串，数组或对象使用内置的方法或属性如 ，， 等时，这是通过 原型继承（prototypal inheritance） 的方式使得我们可以直接调用。 我们经常创建相同类型的多个对象。比方说我们有一个展示宠物狗的网站。对于每个宠物狗，我们需要对应的对象来表示。我们可以通过使用  关键字调用构造函数来创建 Dog…","html":"<p>当我们对字符串，数组或对象使用内置的方法或属性如 <code class=\"language-text\">.length</code>，<code class=\"language-text\">.split()</code>，<code class=\"language-text\">.join()</code> 等时，这是通过 <em>原型继承（prototypal inheritance）</em> 的方式使得我们可以直接调用。</p>\n<p>我们经常创建相同类型的多个对象。比方说我们有一个展示宠物狗的网站。对于每个宠物狗，我们需要对应的对象来表示。我们可以通过使用 <code class=\"language-text\">new</code> 关键字调用构造函数来创建 Dog<strong>实例</strong>。每个 Dog 都有一个 name，breed，color 和 bark 方法。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Dog</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> breed<span class=\"token punctuation\">,</span> color</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>breed <span class=\"token operator\">=</span> breed<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> color<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">bark</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'Woof!'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当我们创建 <code class=\"language-text\">Dog</code> 这个构造函数时，它并不是唯一被创建的。相应的，还自动创建了另一个称为 <em>prototype</em> 的对象。默认情况下，该对象有一个 <em>constructor</em> 属性，是指向原始构造函数的引用，本例中指向 <code class=\"language-text\">Dog</code>。</p>\n<p><img src=\"/c8d9b09d05571666ee6a6f4cef2e922b/prototype.gif\" alt=\"prototype\"></p>\n<p>在 Dog 构造函数上的 <code class=\"language-text\">prototype</code> 属性不可枚举。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> dog1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Daisy'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Labrador'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'black'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> dog2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Jack'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Jack Russell'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'white'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"/326b8a39c1c51ae43434c03c1b1c90d7/dogs.gif\" alt=\"dogs\"></p>\n<p>我们看到除了 <code class=\"language-text\">name</code>, <code class=\"language-text\">breed</code>, <code class=\"language-text\">color</code>, <code class=\"language-text\">bark</code> 之外还有一个 <code class=\"language-text\">__proto__</code> 属性，它也是不可枚举的，就是说我们访问对象时它通常不可见。我们来展开一下：</p>\n<p><img src=\"/82b6553647f5b61f495cbd5bccc27d65/expand-proto.gif\" alt=\"expand __proto__\"></p>\n<p>可以看到 <code class=\"language-text\">__proto__</code> 实际上是 <code class=\"language-text\">Dog.prototype</code> 对象的引用。这就是<strong>原型继承</strong>：每个构造函数的实例都能够访问构造函数的原型。</p>\n<p><img src=\"/7eb31f1b0fa07f0750193bc91b0ec955/access-prototype.gif\" alt=\"access prototype\"></p>\n<p>每个 Dog 都有 <code class=\"language-text\">bark</code> 方法，为了节省每创建一个实例时都要添加该方法消耗的内存，我们可以把它添加到 <code class=\"language-text\">Dog.prototype</code> 对象上。</p>\n<p><img src=\"/855d89c52be7cf25ece8806b99285807/add-method-to-prototype.gif\" alt=\"add method to prototype\"></p>\n<p>当我们在实例上访问属性时，引擎会先在当前实例上查找，如果没有找到，引擎会继续通过 <code class=\"language-text\">__proto__</code> 属性向上层原型链来查找。</p>\n<p><img src=\"/ad44fc3457e5ae5ded069e95211f87d6/walk-prototype-chain.gif\" alt=\"walk prototype chain\"></p>\n<p><code class=\"language-text\">Dog.prototype</code> 本身也是一个对象，就是说它本身是 <code class=\"language-text\">Object</code> 构造函数的实例，<code class=\"language-text\">Dog.prototype</code> 上也有 <code class=\"language-text\">__proto__</code> 属性，它是指向 <code class=\"language-text\">Object.prototype</code> 的引用。</p>\n<p><img src=\"/3b9b9be213a84a782b86db1563b5c0b8/object-prototype.gif\" alt=\"object prototype\"></p>\n<p>现在我们知道了所有内置的方法都是来自原型链。</p>\n<p>例如 <code class=\"language-text\">.toString()</code> 方法，它不是定义在 <code class=\"language-text\">dog1</code> 上，也不在 <code class=\"language-text\">dog1.__proto__</code> 指向的 <code class=\"language-text\">Dog.prototype</code> 上，而是在 <code class=\"language-text\">Dog.prototype.__proto__</code> 对象指向的 <code class=\"language-text\">Object.prototype</code> 上。</p>\n<p><img src=\"/26b6a24098e77270a2e33620ccd6faeb/toString.gif\" alt=\"toString\"></p>\n<p>目前为止我们使用的构造函数（<code class=\"language-text\">function Dog() { ... }</code>）都是基本的 JavaScript 语法。ES6 引入了新的语法来创建构造函数：class。</p>\n<blockquote>\n<p>Class 只是构造函数的语法糖。底层还是原型链的方式工作。</p>\n</blockquote>\n<p>我们通过 <code class=\"language-text\">class</code> 关键字创建 classes，每个 class 都有一个 <code class=\"language-text\">constructor</code> 函数，就像之前 ES5 的语法，添加到原型上的属性可以直接在 classes 体上定义。</p>\n<p><img src=\"/1d5044ec9cce2b71a8b1f2055625a015/define-class.gif\" alt=\"define class\"></p>\n<p>classes 另一个好处是可以方便<strong>继承</strong>其他 classes。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Dog</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">bark</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'Woof!'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Chihuahua</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Dog</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">smallBark</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'Small woof!'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> myPet <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Chihuahua</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Max'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">myPet</code> 能够访问 <code class=\"language-text\">Chihuahua.prototype</code> 和 <code class=\"language-text\">Dog.prototype</code> 对象（还有 <code class=\"language-text\">Object.prototype</code>）。</p>\n<p><img src=\"/1b6a2e893231c26368af1408bdad882f/extend-class.gif\" alt=\"extend class\"></p>\n<p>原型链也是有尽头的， <code class=\"language-text\">Object.prototype.__proto__</code> 的值为 <code class=\"language-text\">null</code>。当我们尝试访问未出现在原型链上的属性时，返回 <code class=\"language-text\">undefined</code>。</p>\n<p><img src=\"/8d77f5dbb379a26f9029b09b8019c9e1/access-property.gif\" alt=\"access property\"></p>\n<p>我们还可以通过 <code class=\"language-text\">Object.create</code> 方法创建对象，通过传入对象参数，返回的对象的原型指向传入的参数。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Lydia'</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> <span class=\"token number\">21</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> me <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>通过控制台来看：</p>\n<p><img src=\"/a45109c2949ffc03caec6a615c717c36/object-create.gif\" alt=\"object create\"></p>\n<p>我们没有向 <code class=\"language-text\">me</code> 对象上添加任何属性，它只有一个 <code class=\"language-text\">__proto__</code> 属性，<code class=\"language-text\">__proto__</code> 属性指向了我们定义作为原型的对象：<code class=\"language-text\">person</code>，它有 <code class=\"language-text\">name</code> 和 <code class=\"language-text\">age</code> 属性。</p>\n<h3>参考</h3>\n<p><a href=\"https://dev.to/lydiahallie/javascript-visualized-prototypal-inheritance-47co\">https://dev.to/lydiahallie/javascript-visualized-prototypal-inheritance-47co</a></p>","frontmatter":{"title":"【译】JavaScript 可视化之原型继承","date":"February 04, 2020","description":"原型继承以图形化的方式展示，方便理解"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tags":["JavaScript Visualized","Prototypal Inheritance"],"slug":"/javascript-visualized-prototypal-inheritance/","previous":{"excerpt":"generator 函数不同于通常的函数，运行就结束。我们可以任意暂停函数的执行，并在合适时机输出。 通过在  关键字后面添加  创建 generator 函数。 generator 函数与普通函数实际上工作方式完全不同： 调用 generator…","fields":{"slug":"/javascript-visualized-generator-function/"},"frontmatter":{"date":"February 05, 2020","description":"迭代器和迭代函数以图形化的方式展示，方便理解","title":"【译】JavaScript 可视化之迭代器和迭代函数","tags":["JavaScript Visualized","Generator","Iterator"]}},"next":{"excerpt":"作为 JavaScript 开发人员，我们有必要了解关于 JavaScript 引擎的基础，它是如何将 JS 代码编译成机器码的。以下内容会以 V8 引擎为主。 HTML 解析器当遇到  标签时，源代码会从该 source 路径从网络，缓存或者安装的 service worker…","fields":{"slug":"/javascript-visualized-engine/"},"frontmatter":{"date":"February 03, 2020","description":"执行引擎以图形化的方式展示，方便理解","title":"【译】JavaScript 可视化之执行引擎","tags":["JavaScript Visualized","Engine"]}}}}}