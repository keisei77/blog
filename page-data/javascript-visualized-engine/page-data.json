{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/javascript-visualized-engine/","result":{"data":{"site":{"siteMetadata":{"title":"学习随笔"}},"markdownRemark":{"id":"51ccf2cf-c59c-5186-807c-863d02aa22c2","excerpt":"作为 JavaScript 开发人员，我们有必要了解关于 JavaScript 引擎的基础，它是如何将 JS 代码编译成机器码的。以下内容会以 V8 引擎为主。 HTML 解析器当遇到  标签时，源代码会从该 source 路径从网络，缓存或者安装的 service worker…","html":"<p>作为 JavaScript 开发人员，我们有必要了解关于 JavaScript 引擎的基础，它是如何将 JS 代码编译成机器码的。以下内容会以 V8 引擎为主。</p>\n<hr>\n<p>HTML 解析器当遇到 <code class=\"language-text\">script</code> 标签时，源代码会从该 source 路径从<strong>网络</strong>，<strong>缓存</strong>或者安装的 <strong>service worker</strong> 中获取。响应的内容为字节流，将由字节流解码器接管，在下载时就开始进行解码。</p>\n<p><img src=\"/9559723c6e73715f10c226f30dc2278c/decoder.gif\" alt=\"byte stream decoder\"></p>\n<p>解码器根据解码的字节生成<strong>令牌（tokens）</strong>。例如，<code class=\"language-text\">0066</code> 解码为 <code class=\"language-text\">f</code>，<code class=\"language-text\">0075</code> 解码为 <code class=\"language-text\">u</code>，<code class=\"language-text\">006e</code> 解码为 <code class=\"language-text\">n</code>，<code class=\"language-text\">0063</code> 解码为 <code class=\"language-text\">c</code>，<code class=\"language-text\">0074</code> 解码为 <code class=\"language-text\">t</code>，<code class=\"language-text\">0069</code> 解码为 <code class=\"language-text\">i</code>，<code class=\"language-text\">006f</code> 解码为 <code class=\"language-text\">o</code>，<code class=\"language-text\">006e</code> 解码为 <code class=\"language-text\">n</code> 并附带一个空格。就像编写的 <code class=\"language-text\">function</code>，这是一个保留的关键字，口令生成后会被发送至解析器（还有预解析器，将在后面解释）。其余的字节流也如此解码。</p>\n<p><img src=\"/6ec45a27a67c0b8f71e6bfb5ed200983/parser.gif\" alt=\"parser\"></p>\n<p>引擎使用两种解析器：预解析器和解析器。为了减少加载网站的时间，引擎尽量避免立即解析非必要的代码。预解析器处理将来可能用到的代码，解析器处理当前用到的代码。如果一个函数只在用户点击按钮后调用，那么在网站加载时就不需要立即去编译这部分代码。如果用户最终按下按钮并请求该段代码，它会被发送至解析器。</p>\n<p>解析器基于从字节流解码器接受的令牌来创建节点。通过这些节点来创建抽象语法树（Abstract Syntax Tree）。</p>\n<p><img src=\"/c64416782ca3527cc76e649ee1aef0aa/ast.gif\" alt=\"ast\"></p>\n<p>下一步是<strong>解释器（interpreter）</strong>的工作。解释器遍历 AST 并基于 AST 包含的信息生成<strong>字节码</strong>。一旦字节码完全生成，AST 会被删除，在内存中释放。最终我们得到了机器可运行的代码。</p>\n<p><img src=\"/9cf8dc84f7da8e0b8bb711e9b154e0a2/interpreter.gif\" alt=\"interpreter\"></p>\n<p>尽管机器码很快，但它还可以更快。在机器码运行时，某些信息也会随之生成。引擎可以检测出哪些行为是经常发生的，哪些数据类型被使用。可能有一个函数被调用了很多次，那么引擎就可以对此进行优化使其执行更快。</p>\n<p>机器码和生成的类型反馈信息会被发送至<strong>优化编译器（optimizing compiler）</strong>。该编译器根据这些数据生成高度优化过的机器码。</p>\n<p><img src=\"/2d949e8d01fa4c41b259210bcd5b349d/optimizing-compiler.gif\" alt=\"optimizing compiler\"></p>\n<p>JavaScript 是一种动态类型语言，意味着数据的类型可以不断变化。如果 JavaScript 引擎每次都要检查某个值的数据类型无疑是非常低效的。</p>\n<p>为了减少解释代码的时间，优化过的机器码只处理引擎之前遇到的运行的字节码的情况。如果我们重复使用那段代码并返回相同的数据类型，优化过的机器码可以直接重复使用来加快运行。然而，当同一段代码返回了不同类型的数据，机器码未优化，引擎只能回退到解释生成的字节码的阶段。</p>\n<p>例如下面的 sum 函数，它每次调用接收数字类型的参数：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>结果返回了 <code class=\"language-text\">3</code>，下次我们调用，它会假设我们仍然传入两个数字的值。</p>\n<p>如果是这样的，不需要动态检索，引擎可以直接使用优化过的机器码。否则，如果假设是错误的，它会回退到最初的字节码而不是优化过的机器码。</p>\n<p>例如，下次我们调用时传入了一个字符串参数：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这会使数字 <code class=\"language-text\">2</code> 强制转换成字符串，函数最终会返回字符串 <code class=\"language-text\">&quot;12&quot;</code>。引擎会执行解释过的字节码并更新类型反馈。</p>\n<h3>相关推荐</h3>\n<p><a href=\"https://v8.dev/\">V8 文档</a> | <a href=\"https://github.com/v8/v8\">V8 Github</a> | <a href=\"https://www.youtube.com/watch?v=voDhHPNMEzg&#x26;t=729s%3Cbr%3E%0A\">Chrome University 2018: Life Of A Script</a></p>\n<h3>参考</h3>\n<p><a href=\"https://dev.to/lydiahallie/javascript-visualized-the-javascript-engine-4cdf\">https://dev.to/lydiahallie/javascript-visualized-the-javascript-engine-4cdf</a></p>","frontmatter":{"title":"JavaScript 可视化之执行引擎","date":"February 03, 2020","description":"执行引擎以图形化的方式展示，方便理解"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tags":["JavaScript Visualized","Engine"],"slug":"/javascript-visualized-engine/","previous":{"excerpt":"当我们对字符串，数组或对象使用内置的方法或属性如 ，， 等时，这是通过 原型继承（prototypal inheritance…","fields":{"slug":"/javascript-visualized-prototypal-inheritance/"},"frontmatter":{"date":"February 04, 2020","description":"原型继承以图形化的方式展示，方便理解","title":"JavaScript 可视化之原型继承","tags":["JavaScript Visualized","Prototypal Inheritance"]}},"next":{"excerpt":"本文假设读者已了解执行上下文的基本概念。 我们首先来看以下代码： 我们调用  函数时，返回了一串包含 ,  和  变量的字符串：。但是  函数内并没有声明变量 `city，它是怎么得到的呢？ JavaScript…","fields":{"slug":"/javascript-visualized-scope/"},"frontmatter":{"date":"February 01, 2020","description":"作用域链以图形化的方式展示，方便理解","title":"JavaScript 可视化之作用域链","tags":["JavaScript Visualized","Scope Chain"]}}}}}