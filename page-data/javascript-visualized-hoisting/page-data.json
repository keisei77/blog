{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/javascript-visualized-hoisting/","result":{"data":{"site":{"siteMetadata":{"title":"学习随笔"}},"markdownRemark":{"id":"91f8f4fa-dc29-5827-8595-ef042e70cdcf","excerpt":"什么是变量提升？ 从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。(MDN) 提升的对象是定义的变量或函数（Declarations），而不是赋值初始化（Initializations…","html":"<p>什么是变量提升？</p>\n<blockquote>\n<p>从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。(<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting\">MDN</a>)</p>\n</blockquote>\n<p>提升的对象是定义的变量或函数（Declarations），而不是赋值初始化（Initializations）。</p>\n<p>当 JS 引擎拿到我们的代码，首先会为我们代码里的数据分配内存。没有代码在此过程运行，只是简单的为执行做准备。函数声明和变量声明的存储方式不同。因为函数也是对象，所以存储的函数是指向函数实际内容的地址引用。</p>\n<p><img src=\"/0bf82098dbf021fa48a75d0ca9a74da2/function.gif\" alt=\"function\"></p>\n<p>ES6 引入了两个定义变量的新关键字：<code class=\"language-text\">let</code> 和 <code class=\"language-text\">const</code>。变量通过 <code class=\"language-text\">let</code> 或 <code class=\"language-text\">const</code> 声明的被存储为 <em>未初始化</em> 。</p>\n<p><img src=\"/dba2e5fef92518d9eb76a44301badd19/variable.gif\" alt=\"variable\"></p>\n<p>变量通过 <code class=\"language-text\">var</code> 关键字声明的在存储时有默认值 <code class=\"language-text\">undefined</code>。</p>\n<p><img src=\"/71934af404a8367c01f4f046a3f5846b/var.gif\" alt=\"var keyword\"></p>\n<p>现在创建阶段完成，可以真正执行代码了。我们来看一下在文件顶部在函数或任何变量声明之前执行 3 个 console.log 表达式会发生什么。</p>\n<p>由于函数是指向实际函数体的引用，我们可以在创建它们那一行之前运行。</p>\n<p><img src=\"/6780331a3551cd3d04078c5732e0217b/invoke.gif\" alt=\"invoke functions\"></p>\n<p>当我们遇到变量通过 <code class=\"language-text\">var</code> 关键字声明的代码时，它们简单的返回存储的默认值：<code class=\"language-text\">undefined</code>。然而这通常不是我们所期望的。</p>\n<p><img src=\"/fe9d78d7bf9419e05ba98a52c9830878/var-hoisting.gif\" alt=\"var hoisting\"></p>\n<p>为了防止意外引用了 <code class=\"language-text\">undefined</code> 变量，可以使用 <code class=\"language-text\">const</code> 关键字，当我们访问 <em>未初始化</em> 的值时会抛出 <code class=\"language-text\">ReferenceError</code> ，这被称为<strong>暂时性死区</strong>：不能在变量初始化之前使用。</p>\n<p><img src=\"tzd.gif\" alt=\"temporal dead zone\"></p>\n<p>当引擎执行到我们真正声明变量的那行代码时，在内存中的值会被实际的值覆盖。</p>\n<p><img src=\"/2354299e4170f18beef4657eba909b61/overwritten.gif\" alt=\"overwritten\"></p>\n<p>快速回顾：</p>\n<ul>\n<li>函数和变量在执行代码前先作为执行上下文存储在内存中</li>\n<li>函数存储了函数体的引用，变量通过 <code class=\"language-text\">var</code> 声明的默认值为 <code class=\"language-text\">undefined</code>，<code class=\"language-text\">let</code> 和 <code class=\"language-text\">const</code> 声明的默认值为 <em>未初始化</em> 。</li>\n</ul>\n<h3>参考</h3>\n<p><a href=\"https://dev.to/lydiahallie/javascript-visualized-hoisting-478h\">https://dev.to/lydiahallie/javascript-visualized-hoisting-478h</a></p>","frontmatter":{"title":"JavaScript 可视化之变量提升","date":"January 28, 2020","description":"变量提升以图形化的方式展示，方便理解"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tags":["JavaScript Visualized","Hoisting"],"slug":"/javascript-visualized-hoisting/","previous":null,"next":{"excerpt":"事件循环大概是每个 JavaScript 初学者都会感到困惑的概念。本文将通过可视化的方式来尽量对该概念作详细的解释。 我们来首先了解一下什么是事件循环，以及我们为什么要关心它？ JavaScript…","fields":{"slug":"/javascript-visualized-event-loop/"},"frontmatter":{"date":"January 25, 2020","description":"事件循环以图形化的方式展示，方便理解","title":"JavaScript 可视化之事件循环","tags":["JavaScript Visualized","Event Loop"]}}}}}