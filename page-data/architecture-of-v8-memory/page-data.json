{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/architecture-of-v8-memory/","result":{"data":{"site":{"siteMetadata":{"title":"学习随笔"}},"markdownRemark":{"id":"0b3187b4-8f8b-5c75-ac58-e8a88ed43f20","excerpt":"本文我们来看一下用于ECMAScript和WebAssembly的V8 引擎的内存管理。V8 引擎现在被 NodeJS，Deno 等运行时，Electron，还有 Chrome，Chromium，Brave，Opera 和 Microsoft Edge 等浏览器采用。由于 JavaScript…","html":"<p>本文我们来看一下用于<a href=\"https://tc39.es/ecma262/\">ECMAScript</a>和<a href=\"https://webassembly.github.io/spec/core/\">WebAssembly</a>的<a href=\"https://v8.dev/\">V8 引擎</a>的内存管理。V8 引擎现在被 NodeJS，Deno 等运行时，Electron，还有 Chrome，Chromium，Brave，Opera 和 Microsoft Edge 等浏览器采用。由于 JavaScript 是一门解释型语言，需要引擎来解释并执行。V8 引擎解释 JavaScript 代码并将代码编译成原生的机器码。V8 引擎是通过 C++编写的，可以嵌套在任意的 C++程序中。</p>\n<h3>V8 内存架构</h3>\n<p>由于 JavaScript 是单线程的，V8 会在每个 JavaScript 上下文中使用一个单独的进程，如果使用了 service worker，它会根据每个 worker 产生一个新的 V8 进程。每个运行中的应用程序总是被 V8 进程分配一些内存，被称为<strong>常驻集（Resident Set）</strong>。然后被进一步分为一下不同的片段：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/51d594675e95270d44f2ba31e0459f30/b7c40/memory-structure-of-V8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAACZ0lEQVQoz2O4cvP2teXrTs9ZeWbuyrPzVp2btwrIgKDLS9YdXLB177xN++Zt2j9v8745W3fP3rJ7zpads7acXbrl6o1bDHevXV9V2RVY1BZT3R1d2p6R3RxR0Rld1R1a3LIkta+spDFnbmTerNjCicm+/rPkgqYrh06X8Jo2J2fO/etXGO5du7Gkrt+lpjekY6p/fV9kQatP04SQzqme9V0LsiaV1dUXbAgvWh1bND/B0X+mcPgMhYTZfAEzZuTPv3/jKsPNmzcPFHXNDW9clt69LK17VXrPstTOpcld84Obt6RNLIxckxG5vCx9bXn6qprsXaUZOwoSN8cFbVpatuIu0OZr12/ebey4ll12s6jmZmH1jcLq29Ud97rbbjUl3ulIPdWce6Ip/3xn5anWmfODYhaGxi2JSp3sErgnv/Q20M9Xb9x+UlX5MCn+cV7u47ych8kJT4srXs8qfTFJ/eU007ezrV9P0Xoz1ezZxI7pxgozzJXmO+hO0BLenRBy+9Y9hivXbj5u63hYXv6ophaIHlZUPG5qez6t5enEqKeT4p5OTnw6Meb5lNQHfd3z7I0Xedsu9XOaYaO7JyXm1s27DNev3fi6dMG3JfOhCMJeNO/78qXf16z6vnrlt6WLvy9Z/GH21PU+lhuDHbbHei131jtXknbn9l2Gw9futS0+3rLoWCsCHQeRi493rTjdteIUkAERbF5wpGn+oaZ5B5vmH25dePTQ1XsMu688CJt+Lmja2WBUFDjlTMLcC0AEZEBEQqadC5kOQsHTzoVOP7fz0n2GCw8eX3yIHZ2//+j8g0e4ZIEaAWRwlfz83vVPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"memory structure of V8\"\n        title=\"memory structure of V8\"\n        src=\"/static/51d594675e95270d44f2ba31e0459f30/799d3/memory-structure-of-V8.png\"\n        srcset=\"/static/51d594675e95270d44f2ba31e0459f30/00d96/memory-structure-of-V8.png 148w,\n/static/51d594675e95270d44f2ba31e0459f30/0b23c/memory-structure-of-V8.png 295w,\n/static/51d594675e95270d44f2ba31e0459f30/799d3/memory-structure-of-V8.png 590w,\n/static/51d594675e95270d44f2ba31e0459f30/2a3d6/memory-structure-of-V8.png 885w,\n/static/51d594675e95270d44f2ba31e0459f30/b7c40/memory-structure-of-V8.png 960w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>堆内存</h3>\n<p>这是 V8 存储对象或动态数据的地方。这是内存区域最大的块，这也是<strong>垃圾回收（Garbage Collection）</strong>发生的地方。并不是整个堆内存都会被回收，只有新生代和老生代会被垃圾回收管理。堆会进一步分为：</p>\n<ul>\n<li><strong>新生代（New Space）</strong> 新生代或“<strong>年轻代（Young generation）</strong>”是新对象存储的地方，这些新对象通常都是短暂存活的。这块内存非常小，有两个 semi-space。这块内存被“清道夫（<strong>Scavenger(Minor GC)</strong>）”管理。新生代可以通过 <code class=\"language-text\">--min_semi_space_size(初始化)</code> 和 <code class=\"language-text\">--max_semi_space_size(最大)</code> 标志来控制大小。</li>\n<li>\n<p><strong>老生代（Old Space）</strong> 老生代或“<strong>老年代（Old generation）</strong>”是那些在新生代中在两次次要 GC 中存活下来的对象。这块内存是被“<strong>主 GC（Major GC: Mark-Sweep &#x26; Mark-Compact）</strong>”管理。老生代可以通过 <code class=\"language-text\">--initial_old_space_size(初始化)</code> 和 <code class=\"language-text\">--max_old_space_size(最大)</code> 标志来控制大小。这块内存又被分为两份：</p>\n<ul>\n<li><strong>旧指针空间（Old pointer space）</strong>：包含具有指向其他对象的幸存对象</li>\n<li><strong>旧数据空间（Old data space）</strong>：包含保存数据的对象（没有指向其他的对象）。字符串，包装过的数字等保存新生代中在两次次要 GC 中存活下来的对象。</li>\n</ul>\n</li>\n<li><strong>大对象空间（Large object space）</strong>：这是超过其他内存限制的更大的对象存活的地方。大对象不会被垃圾回收。</li>\n<li><strong>代码空间（Code-space）</strong>：这是即时（<strong>Just In Time: JIT</strong>）编译器存储编译过的代码的地方。这是唯一可执行的内存空间（尽管代码可能被分配在“大对象空间”，这些也是可执行的）。</li>\n<li><strong>细胞空间，属性细胞空间，map 空间（Cell space, property cell space, and map space）</strong>：这些空间分别包含：<code class=\"language-text\">Cells</code>, <code class=\"language-text\">PropertyCells</code>, 和 <code class=\"language-text\">Maps</code>。这些空间中的每个空间都包含相同大小的对象，并且对它们指向的对象有一些限制，从而简化了回收。</li>\n</ul>\n<p>这些空间中的每一个都由一组 pages 组成。Page 是使用 mmap 从操作系统分配的连续内存块。除较大的对象空间外，每个页面的大小均为 1MB。</p>\n<h3>参考</h3>\n<p><a href=\"https://deepu.tech/memory-management-in-v8/\">https://deepu.tech/memory-management-in-v8/</a></p>","frontmatter":{"title":"可视化了解 V8 内存管理","date":"February 24, 2020","description":"对V8的内存管理以可视化的方式来加以了解"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tags":["V8","Garbage Collection"],"slug":"/architecture-of-v8-memory/","previous":null,"next":{"excerpt":"笔者之前接手过一些小程序的项目，不过当时时间紧任务重，基本上就是边看文档边撸代码，并没有真正好好的理解小程序的设计。今天准备花些时间来了解一下，小程序背后的故事。 前世今生 小程序这个概念应该是微信最早提出并推广应用的。当时发布之后我也尝试做过类似 Instagram…","fields":{"slug":"/architecture-of-miniprogram/"},"frontmatter":{"date":"February 23, 2020","description":"本文以微信小程序为例，来了解微信小程序的架构和底层实现原理","title":"初识小程序架构","tags":["Mini Program"]}}}}}