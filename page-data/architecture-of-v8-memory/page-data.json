{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/architecture-of-v8-memory/","result":{"data":{"site":{"siteMetadata":{"title":"学习随笔"}},"markdownRemark":{"id":"0b3187b4-8f8b-5c75-ac58-e8a88ed43f20","excerpt":"本文我们来看一下用于ECMAScript和WebAssembly的V8 引擎的内存管理。V8 引擎现在被 NodeJS，Deno 等运行时，Electron，还有 Chrome，Chromium，Brave，Opera 和 Microsoft Edge 等浏览器采用。由于 JavaScript…","html":"<p>本文我们来看一下用于<a href=\"https://tc39.es/ecma262/\">ECMAScript</a>和<a href=\"https://webassembly.github.io/spec/core/\">WebAssembly</a>的<a href=\"https://v8.dev/\">V8 引擎</a>的内存管理。V8 引擎现在被 NodeJS，Deno 等运行时，Electron，还有 Chrome，Chromium，Brave，Opera 和 Microsoft Edge 等浏览器采用。由于 JavaScript 是一门解释型语言，需要引擎来解释并执行。V8 引擎解释 JavaScript 代码并将代码编译成原生的机器码。V8 引擎是通过 C++编写的，可以嵌套在任意的 C++程序中。</p>\n<h3>V8 内存架构</h3>\n<p>由于 JavaScript 是单线程的，V8 会在每个 JavaScript 上下文中使用一个单独的进程，如果使用了 service worker，它会根据每个 worker 产生一个新的 V8 进程。每个运行中的应用程序总是被 V8 进程分配一些内存，被称为<strong>常驻集（Resident Set）</strong>。然后被进一步分为一下不同的片段：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/51d594675e95270d44f2ba31e0459f30/b7c40/memory-structure-of-V8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAACZ0lEQVQoz2O4cvP2teXrTs9ZeWbuyrPzVp2btwrIgKDLS9YdXLB177xN++Zt2j9v8745W3fP3rJ7zpads7acXbrl6o1bDHevXV9V2RVY1BZT3R1d2p6R3RxR0Rld1R1a3LIkta+spDFnbmTerNjCicm+/rPkgqYrh06X8Jo2J2fO/etXGO5du7Gkrt+lpjekY6p/fV9kQatP04SQzqme9V0LsiaV1dUXbAgvWh1bND/B0X+mcPgMhYTZfAEzZuTPv3/jKsPNmzcPFHXNDW9clt69LK17VXrPstTOpcld84Obt6RNLIxckxG5vCx9bXn6qprsXaUZOwoSN8cFbVpatuIu0OZr12/ebey4ll12s6jmZmH1jcLq29Ud97rbbjUl3ulIPdWce6Ip/3xn5anWmfODYhaGxi2JSp3sErgnv/Q20M9Xb9x+UlX5MCn+cV7u47ych8kJT4srXs8qfTFJ/eU007ezrV9P0Xoz1ezZxI7pxgozzJXmO+hO0BLenRBy+9Y9hivXbj5u63hYXv6ophaIHlZUPG5qez6t5enEqKeT4p5OTnw6Meb5lNQHfd3z7I0Xedsu9XOaYaO7JyXm1s27DNev3fi6dMG3JfOhCMJeNO/78qXf16z6vnrlt6WLvy9Z/GH21PU+lhuDHbbHei131jtXknbn9l2Gw9futS0+3rLoWCsCHQeRi493rTjdteIUkAERbF5wpGn+oaZ5B5vmH25dePTQ1XsMu688CJt+Lmja2WBUFDjlTMLcC0AEZEBEQqadC5kOQsHTzoVOP7fz0n2GCw8eX3yIHZ2//+j8g0e4ZIEaAWRwlfz83vVPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"memory structure of V8\"\n        title=\"memory structure of V8\"\n        src=\"/static/51d594675e95270d44f2ba31e0459f30/799d3/memory-structure-of-V8.png\"\n        srcset=\"/static/51d594675e95270d44f2ba31e0459f30/00d96/memory-structure-of-V8.png 148w,\n/static/51d594675e95270d44f2ba31e0459f30/0b23c/memory-structure-of-V8.png 295w,\n/static/51d594675e95270d44f2ba31e0459f30/799d3/memory-structure-of-V8.png 590w,\n/static/51d594675e95270d44f2ba31e0459f30/2a3d6/memory-structure-of-V8.png 885w,\n/static/51d594675e95270d44f2ba31e0459f30/b7c40/memory-structure-of-V8.png 960w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h4>堆内存</h4>\n<p>这是 V8 存储对象或动态数据的地方。这是内存区域最大的块，这也是<strong>垃圾回收（Garbage Collection）</strong>发生的地方。并不是整个堆内存都会被回收，只有新生代和老生代会被垃圾回收管理。堆会进一步分为：</p>\n<ul>\n<li><strong>新生代（New Space）</strong> 新生代或“<strong>年轻代（Young generation）</strong>”是新对象存储的地方，这些新对象通常都是短暂存活的。这块内存非常小，有两个 semi-space。这块内存被“清道夫（<strong>Scavenger(Minor GC)</strong>）”管理。新生代可以通过 <code class=\"language-text\">--min_semi_space_size(初始化)</code> 和 <code class=\"language-text\">--max_semi_space_size(最大)</code> 标志来控制大小。</li>\n<li>\n<p><strong>老生代（Old Space）</strong> 老生代或“<strong>老年代（Old generation）</strong>”是那些在新生代中在两次次要 GC 中存活下来的对象。这块内存是被“<strong>主 GC（Major GC: Mark-Sweep &#x26; Mark-Compact）</strong>”管理。老生代可以通过 <code class=\"language-text\">--initial_old_space_size(初始化)</code> 和 <code class=\"language-text\">--max_old_space_size(最大)</code> 标志来控制大小。这块内存又被分为两份：</p>\n<ul>\n<li><strong>旧指针空间（Old pointer space）</strong>：包含具有指向其他对象的幸存对象</li>\n<li><strong>旧数据空间（Old data space）</strong>：包含保存数据的对象（没有指向其他的对象）。字符串，包装过的数字等保存新生代中在两次次要 GC 中存活下来的对象。</li>\n</ul>\n</li>\n<li><strong>大对象空间（Large object space）</strong>：这是超过其他内存限制的更大的对象存活的地方。大对象不会被垃圾回收。</li>\n<li><strong>代码空间（Code-space）</strong>：这是即时（<strong>Just In Time: JIT</strong>）编译器存储编译过的代码的地方。这是唯一可执行的内存空间（尽管代码可能被分配在“大对象空间”，这些也是可执行的）。</li>\n<li><strong>细胞空间，属性细胞空间，map 空间（Cell space, property cell space, and map space）</strong>：这些空间分别包含：<code class=\"language-text\">Cells</code>, <code class=\"language-text\">PropertyCells</code>, 和 <code class=\"language-text\">Maps</code>。这些空间中的每个空间都包含相同大小的对象，并且对它们指向的对象有一些限制，从而简化了回收。</li>\n</ul>\n<p>这些空间中的每一个都由一组 pages 组成。Page 是使用 mmap 从操作系统分配的连续内存块。除较大的对象空间外，每个页面的大小均为 1MB。</p>\n<h4>栈内存</h4>\n<p>每个 V8 进程会有对应的栈。这里是静态数据，包含方法/函数帧，基本数据，指向对象的指针存放的地方。栈内存的大小限制可以通过 <code class=\"language-text\">--stack_size</code> 标志控制。</p>\n<h3>V8 内存使用（栈 vs 堆）</h3>\n<p>现在我们已经清楚内存是如何管理的，我们来看一下当应用运行时内存是如何使用的。</p>\n<p>我们来看下面这段代码，注意代码并未优化，主要来关注栈和堆的内存使用。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Employee</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> salary<span class=\"token punctuation\">,</span> sales</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>salary <span class=\"token operator\">=</span> salary<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sales <span class=\"token operator\">=</span> sales<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">BONUS_PERCENTAGE</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getBonusPercentage</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">salary</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> percentage <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>salary <span class=\"token operator\">*</span> <span class=\"token constant\">BONUS_PERCENTAGE</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> percentage<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">findEmployeeBonus</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">salary<span class=\"token punctuation\">,</span> noOfSales</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> bonusPercentage <span class=\"token operator\">=</span> <span class=\"token function\">getBonusPercentage</span><span class=\"token punctuation\">(</span>salary<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> bonus <span class=\"token operator\">=</span> bonusPercentage <span class=\"token operator\">*</span> noOfSales<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> bonus<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> john <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Employee</span><span class=\"token punctuation\">(</span><span class=\"token string\">'John'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\njohn<span class=\"token punctuation\">.</span>bonus <span class=\"token operator\">=</span> <span class=\"token function\">findEmployeeBonus</span><span class=\"token punctuation\">(</span>john<span class=\"token punctuation\">.</span>salary<span class=\"token punctuation\">,</span> john<span class=\"token punctuation\">.</span>sales<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>john<span class=\"token punctuation\">.</span>bonus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 66.66666666666666%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <iframe src=\"https://speakerdeck.com/deepu105/v8-memory-usage-stack-and-heap\" style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>\n<p>相关 slide 可以<a href=\"https://speakerdeck.com/deepu105/v8-memory-usage-stack-and-heap\" target=\"_blank\">点击新窗口打开</a></p>\n<p>可以看到：</p>\n<ul>\n<li>全局作用域是存在于栈的“全局帧”中</li>\n<li>每个函数调用都作为帧块被加入栈内存</li>\n<li>所有的局部变量包括参数和返回值都在栈的函数帧块中</li>\n<li>所有的原始数据如 <code class=\"language-text\">int</code> 和 <code class=\"language-text\">string</code> 都被直接存入栈中。这也适用全局作用域</li>\n<li>所有的对象类型如 <code class=\"language-text\">Employee</code> 和 <code class=\"language-text\">Function</code> 都在堆中被创建，从栈中使用栈指针引用它们。在 JavaScript 中函数本质上是对象，这也适用全局作用域</li>\n<li>从当前函数调用的函数被加入栈顶</li>\n<li>当函数返回时，它的帧在栈中被移除</li>\n<li>一旦主流程完成，堆中的内存没有栈中任何的指针指向会成为孤儿对象</li>\n<li>除非做了复制，其他对象内的所有对象引用都使用引用指针</li>\n</ul>\n<p>栈就像看到的一样是操作系统而不是 V8 本身管理并结束的，因此我们不需要太关注栈。相反，堆内存不是操作系统自动管理的，由于它有最大的内存空间并存储动态数据，可能随着时间增长呈指数增长以至程序执行用光内存。这就是垃圾回收需要的原因。</p>\n<p>对于垃圾回收区分堆中的指针和数据是非常重要的，V8 使用“<strong>标记指针（Tagged pointer）</strong>”的方式来回收，它在每个字母后面预留了一比特来标记是指针还是数据。这个方式需要有限的编译器支持，但实现起来很简单，而且效率很高。</p>\n<h3>参考</h3>\n<p><a href=\"https://deepu.tech/memory-management-in-v8/\">https://deepu.tech/memory-management-in-v8/</a></p>","frontmatter":{"title":"可视化了解 V8 内存管理","date":"February 24, 2020","description":"对V8的内存管理以可视化的方式来加以了解"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tags":["V8","Garbage Collection"],"slug":"/architecture-of-v8-memory/","previous":null,"next":{"excerpt":"笔者之前接手过一些小程序的项目，不过当时时间紧任务重，基本上就是边看文档边撸代码，并没有真正好好的理解小程序的设计。今天准备花些时间来了解一下，小程序背后的故事。 前世今生 小程序这个概念应该是微信最早提出并推广应用的。当时发布之后我也尝试做过类似 Instagram…","fields":{"slug":"/architecture-of-miniprogram/"},"frontmatter":{"date":"February 23, 2020","description":"本文以微信小程序为例，来了解微信小程序的架构和底层实现原理","title":"初识小程序架构","tags":["Mini Program"]}}}}}