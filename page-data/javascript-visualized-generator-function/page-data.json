{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/javascript-visualized-generator-function/","result":{"data":{"site":{"siteMetadata":{"title":"学习随笔"}},"markdownRemark":{"id":"3bff8f1b-d6e5-512d-a880-b9a1721c55da","excerpt":"generator 函数不同于通常的函数，运行就结束。我们可以任意暂停函数的执行，并在合适时机输出。 通过在  关键字后面添加  创建 generator 函数。 generator 函数与普通函数实际上工作方式完全不同： 调用 generator…","html":"<p>generator 函数不同于通常的函数，运行就结束。我们可以任意暂停函数的执行，并在合适时机输出。</p>\n<p>通过在 <code class=\"language-text\">function</code> 关键字后面添加 <code class=\"language-text\">*</code> 创建 generator 函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// function *generatorFunction() {} 这样也是可以的</span>\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">generatorFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>generator 函数与普通函数实际上工作方式完全不同：</p>\n<ul>\n<li>调用 generator 函数返回<strong>生成器对象</strong>，实际上是一个迭代器</li>\n<li>我们可以使用 <code class=\"language-text\">yield</code> 关键字来“暂停”执行</li>\n</ul>\n<p><img src=\"/1177388af025abcd4fd2cd7c5ce49089/generator-return-value.gif\" alt=\"generator return value\"></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">genFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token string\">':sparkles:'</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'First log!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token string\">':two_hearts:'</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Second log!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'Done!'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当遇到 <code class=\"language-text\">yield</code> 关键字时，generator 函数的执行会暂停。下次我们再运行该函数时，它会记住上次暂停的位置，并从该位置开始执行：</p>\n<ol>\n<li>第一次执行，它在第一行暂停，并 <em>产出</em> 字符串:sparkles:</li>\n<li>第二次执行，从上一个 <code class=\"language-text\">yield</code> 关键字的行开始，直到遇到第二个 <code class=\"language-text\">yield</code> 关键字并 <em>产出</em> :two_hearts:</li>\n<li>第三次执行，从上一个 <code class=\"language-text\">yield</code> 关键字的行开始，直到遇到 <code class=\"language-text\">return</code> 关键字，并 <em>返回</em> <code class=\"language-text\">Done!</code></li>\n</ol>\n<p>当调用 generator 函数返回了生成器对象，我们下次该如何调用呢？生成器对象在原型链上拥有一个 <code class=\"language-text\">next</code> 方法，这个方法是用来迭代生成器对象的。</p>\n<p><img src=\"/4065f02ab5025440562a201eb9746d8b/set-variable-to-generator-object.gif\" alt=\"set variable to generator object\"></p>\n<p><img src=\"/580c5d114dac318beb7b5f478a358dc4/call-next.gif\" alt=\"call next\"></p>\n<p>调用 <code class=\"language-text\">next</code> 方法返回值为一个对象，包含 <code class=\"language-text\">value</code> 属性和 <code class=\"language-text\">done</code> 属性，<code class=\"language-text\">value</code> 的值就产出的值，<code class=\"language-text\">done</code> 是一个布尔值，只有遇到 <em>return</em> 时才会置为 <code class=\"language-text\">true</code>。</p>\n<p><img src=\"/45a46b8c570a3280f6f8403015ceb9dd/invoke.gif\" alt=\"invoke all next\"></p>\n<p><img src=\"/ef914d69af50f342e1ee3cce50cbb2a8/invoke-after-done.gif\" alt=\"invoke after done\"></p>\n<p>当 <code class=\"language-text\">done</code> 为 <code class=\"language-text\">true</code> 时，再次调用 next()，返回的 <code class=\"language-text\">value</code> 会永远为 <code class=\"language-text\">undefined</code>。</p>\n<hr>\n<p>那什么是迭代器呢？它可以在 <code class=\"language-text\">for ... of</code> 循环和扩展运算符中使用。</p>\n<p><img src=\"/65b9e5b7297b53f9902558d82017b99c/spread-operator.gif\" alt=\"spread operator\"></p>\n<p><img src=\"/d8af13fef372e0a5511d913bddb6906b/for-of-loop.gif\" alt=\"for of loop\"></p>\n<p>为什么迭代器如 array，string，map 和 set 可以迭代呢？实际上它们都实现了 <em>迭代器协议</em> ：<code class=\"language-text\">[Symbol.iterator]</code>。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f6b34ef4b42b6cf56085ee7fde6b3c7d/50fa5/iterator-code.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 84.43181818181817%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsSAAALEgHS3X78AAAC7UlEQVQ4y62Ty27TQBSGB6dpGyc0QkgISqvY47l4bMfx3YmTNOLaghAIBAhY8Qaw4iF4DV6ALcqGBRKqBOIloCxAQiwBV4djt0IFRGGBpU/Hkyif/98zIQSv7vEucR1G7uZTci1Pyc1Nj2wUfXLl6jly+3pOJrOQPNq6RzanQ3LtzpjcuHWBpFlA4sQjWT4gXl+QU6snSH2trp0k/+ti3CDk4YP79UII87GU9AXyTNrmXEhzLm06txWdV2tHsbm9v7aVVX+PPEOeI09WV0+0D8qXJTfeTF0PElfAMKKQhhLCyINgwMDFzwp3AMrlMIg5+AMblMMAxeC4DLgwPh871l0/KGxzbrzMlA0Dxb7EvlnGPi0dl5f+gJdhKMoBzjiR9X0YiRKTlpjsK7aohO9Wuh3jV+F2rlQlLCPfhMSn4HkCvD6DKBKAIkhTG1MLiGOJ6WiVcLdKicL33e7R3k9CgcKRciB0WDmODQg8E9y+A36CNYd71fLchiSROBVKRVX9ECGrhAoyibUUg2FoQh7QemYBEnJM59bvDTepBiv/WciEsT12XTgvvTK1BUxHAmaFDbOxDRs4x5huY+oDvke4OPGg71WbcYhQ2HRb+QKo7JUWPp1yWmOJPSg3Ac9ZlQqEsHBSEPYhQs5622PbgUIqTCihiClMEgqjqJpWPYsENyTp4/u06k35a+XCc+GsdMsEKxd5VduGCXJm6sBsomCEtUcjF4ZDBUEg/lJZ0peqj5VF75uFT7b4Hkzs3zMD6e0y3ttFQQ0mLPfP4c5vQvynvN5wPMjx7M0yCuPYqqueySzcZQpRFkA6G0E8ySCZ5vWMihTSUQxKWR/bHf2ng60bxumnnPY+Mbr+VvD1Hcb24IhlIdzYYdKs5wHeIR9Mc+2V3m6tHRQ2kQC5jGwhl/6Rrf3fDKtQP2yNxQWy1Gwe6SwsafpiU+vqDa2zvIA0tJVWQ9OXGlqrrWv6ylGt1Wn/YLmN6K3GYrOpLS41a9d3t71D+on6Rp8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"iterator code\"\n        title=\"iterator code\"\n        src=\"/static/f6b34ef4b42b6cf56085ee7fde6b3c7d/799d3/iterator-code.png\"\n        srcset=\"/static/f6b34ef4b42b6cf56085ee7fde6b3c7d/00d96/iterator-code.png 148w,\n/static/f6b34ef4b42b6cf56085ee7fde6b3c7d/0b23c/iterator-code.png 295w,\n/static/f6b34ef4b42b6cf56085ee7fde6b3c7d/799d3/iterator-code.png 590w,\n/static/f6b34ef4b42b6cf56085ee7fde6b3c7d/50fa5/iterator-code.png 880w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><img src=\"/b6cdf7f555289198eea3ace785453216/symbol-iterator.gif\" alt=\"symbol iterator\"></p>\n<p><img src=\"/ea60169eb55a3b1f98e666686f12ad16/pass-value-to-next.gif\" alt=\"pass value to next\"></p>\n<hr>\n<p>生成器一个最大的优势是它们可以<strong>惰性求值</strong>。这意味着每次调用 <code class=\"language-text\">next</code> 方法才返回值，只在我们需要是才会计算。</p>\n<p><img src=\"/24a2874bfb25cfa43e733bf10705972c/lazy-evaluated.gif\" alt=\"lazy evaluated\"></p>\n<h3>参考</h3>\n<p><a href=\"https://dev.to/lydiahallie/javascript-visualized-generators-and-iterators-e36\">https://dev.to/lydiahallie/javascript-visualized-generators-and-iterators-e36</a></p>","frontmatter":{"title":"JavaScript 可视化之迭代器和迭代函数","date":"February 05, 2020","description":"迭代器和迭代函数以图形化的方式展示，方便理解"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tags":["JavaScript Visualized","Generator","Iterator"],"slug":"/javascript-visualized-generator-function/","previous":{"excerpt":"参考 https://itnext.io/server-side-rendering-with-react-redux-and-react-router-fa5b67d4965e?_branch_match_id=755024804793509077&gi=cd56fb5a…","fields":{"slug":"/react-ssr/"},"frontmatter":{"date":"February 09, 2020","description":"SSR 的入门学习","title":"React SSR 初体验","tags":["React","SSR"]}},"next":{"excerpt":"当我们对字符串，数组或对象使用内置的方法或属性如 ，， 等时，这是通过 原型继承（prototypal inheritance…","fields":{"slug":"/javascript-visualized-prototypal-inheritance/"},"frontmatter":{"date":"February 04, 2020","description":"原型继承以图形化的方式展示，方便理解","title":"JavaScript 可视化之原型继承","tags":["JavaScript Visualized","Prototypal Inheritance"]}}}}}