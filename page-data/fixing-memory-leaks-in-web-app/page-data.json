{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/fixing-memory-leaks-in-web-app/","result":{"data":{"site":{"siteMetadata":{"title":"学习随笔"}},"markdownRemark":{"id":"14bc7aee-3398-5db2-86c6-3d33699368e4","excerpt":"当我们从构建服务端渲染的网站切换到构建客户端渲染的单页面应用时，我们需要对用户设备上的资源格外小心。不能阻碍 UI 线程，不要使笔记本风扇快速旋转，不要榨干手机的电池等等。我们为了更好的交互和类似原生应用的体验而带来的这些问题是服务端渲染所不存在的。 其中一个很重要的问题是内存泄漏。一个糟糕实现的 SPA…","html":"<p>当我们从构建服务端渲染的网站切换到构建客户端渲染的单页面应用时，我们需要对用户设备上的资源格外小心。不能阻碍 UI 线程，不要使笔记本风扇快速旋转，不要榨干手机的电池等等。我们为了更好的交互和类似原生应用的体验而带来的这些问题是服务端渲染所不存在的。</p>\n<p>其中一个很重要的问题是内存泄漏。一个糟糕实现的 SPA 可以轻松吃掉 MB 级内存甚至 GB 级的内存，甚至在后台 tab 中也会持续吞噬资源。这时页面开始变慢，甚至浏览器直接终结这个 tab：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 570px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2a8b7d6e23c2563f2c7e1e2f51123c08/f65ec/aw-snap.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.631578947368425%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAAAfUlEQVQY052QPQ7CMAyFfW5OBAMLl4AOSEggJhbWZIn/SGWHlKCOVALy7OHzYD/bkPNYa526BOfLNaXUqGMEhBhVtdOZiEKIxPJ7T1txTiBEJhIRbcHyZuLGiOjuX5xZ/TGW55I+vzDX672tNnl3NDCrXv479XAr28FO9/ICVWWbxk/ldyoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"aw snap\"\n        title=\"aw snap\"\n        src=\"/static/2a8b7d6e23c2563f2c7e1e2f51123c08/f65ec/aw-snap.png\"\n        srcset=\"/static/2a8b7d6e23c2563f2c7e1e2f51123c08/00d96/aw-snap.png 148w,\n/static/2a8b7d6e23c2563f2c7e1e2f51123c08/0b23c/aw-snap.png 295w,\n/static/2a8b7d6e23c2563f2c7e1e2f51123c08/f65ec/aw-snap.png 570w\"\n        sizes=\"(max-width: 570px) 100vw, 570px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>当然，服务端渲染的网站也可能会在服务端出现内存泄漏。但它完全不像客户端的内存泄漏，因为浏览器在每次切换页面时都会清除内存。</p>\n<p>关于内存泄漏的主题在 web 开发文献中并没有很好地覆盖。可以肯定的是，大多数的 SPA 应用都存在内存泄漏，除非这些团队有健壮的基础设施来捕获并修复内存泄漏。在 JavaScript 中太容易分配了内存却疏忽清理。</p>\n<p>为什么没有多少人写有关内存泄漏的文章呢？大概如下：</p>\n<ul>\n<li><strong>没有多少抱怨</strong>：没有多少用户在浏览网页时去用心关注任务管理器。通常，我们不会听到用户的抱怨，除非泄露非常严重使 tab 直接崩溃或应用变慢</li>\n<li><strong>缺少数据</strong>：没有团队或应用提供测量网站存在多少内存泄露的功能</li>\n<li><strong>缺少工具</strong>：现有的工具也很难简单去检查或修复内存泄漏</li>\n<li><strong>缺少关注</strong>：浏览器会扼杀那些占用内存过多的 tab 页，用户更可能去抱怨浏览器而不是网站</li>\n</ul>\n<p>在本文将来介绍一些修复内存泄漏的经验，并提供一些例子来高效鉴别它们。</p>\n<h3>内存泄漏剖析</h3>\n<p>现代 web 应用框架像 React，Vue 和 Svelte 都是基于组件的模型。在这种模型下，最常见的一种内存泄漏是：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">onMessage</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这就会造成内存泄漏。如果在全局对象（<code class=\"language-text\">window</code>，<code class=\"language-text\">&lt;body&gt;</code> 等）上调用 <code class=\"language-text\">addEventListener</code> 却忘记在组件卸载时通过 <code class=\"language-text\">removeEventListener</code> 清除，那么就造成了内存泄漏。</p>\n<p>更坏的是，我们直接泄露了整个组件。因为 <code class=\"language-text\">this.onMessage</code> 是绑定在 <code class=\"language-text\">this</code> 上，这个组件被泄露了。它的子组件也被泄露了，而且很有可能所有有关这些组件的 DOM 节点也被泄露了。这会很快变得糟糕。</p>\n<p>可以通过下面来解决：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 挂载阶段</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onMessage <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">onMessage</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onMessage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 卸载阶段</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">removeEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onMessage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>注意我们缓存了对绑定的 <code class=\"language-text\">onMessage</code> 函数的引用。必须向 <code class=\"language-text\">removeEventListener</code> 传入和 <code class=\"language-text\">addEventListener</code> 完全一样的函数，否则不会生效。</p>\n<h3>内存泄漏常见情况</h3>\n<p>常见的造成内存泄漏的 API：</p>\n<ol>\n<li><code class=\"language-text\">addEventListener</code>，最常见的一种。调用 <code class=\"language-text\">removeEventListener</code> 来清除。</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout\"><code class=\"language-text\">setTimeout</code></a> / <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval\"><code class=\"language-text\">setInterval</code></a>，如果创建了递归的计时器（如每 30 秒执行一次），那么需要通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/clearTimeout\"><code class=\"language-text\">clearTimeout</code></a> 或 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/clearInterval\"><code class=\"language-text\">clearInterval</code></a> 来清除。（如果 <code class=\"language-text\">setTimeout</code> 像 <code class=\"language-text\">setInterval</code> 那么使用会造成泄漏，即在 <code class=\"language-text\">setTimeout</code> 回调内部调用 <code class=\"language-text\">setTimeout</code>）。</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver\"><code class=\"language-text\">IntersectionObserver</code></a>，<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver\"><code class=\"language-text\">ResizeObserver</code></a>，<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\"><code class=\"language-text\">MutationObserver</code></a>等。这些新的 API 非常方便，但是它们很容易造成泄漏。如果在一个组件中创建了它们，并且它绑定到了一个全局可见的元素上，那么需要调用 <code class=\"language-text\">disconnect()</code> 来清理。（注意垃圾回收 DOM 节点时，也会回收它们的监听器和 observer。所以通常只需要关心全局的元素，如 <code class=\"language-text\">&lt;body&gt;</code>，<code class=\"language-text\">document</code> 以及全局可见的 header/footer 元素等）。</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code class=\"language-text\">Promises</code></a>，<a href=\"https://rxjs.dev/guide/observable\"><code class=\"language-text\">Observables</code></a>，<a href=\"https://nodejs.org/api/events.html#events_class_eventemitter\"><code class=\"language-text\">EventEmitters</code></a>等。如果忘记停止监听，那么任何模型上设置的监听器都可能泄漏。（一个 Promise 如果永远没有 resolved 或 rejected，那么任何附着的 <code class=\"language-text\">.then()</code> 回调都会泄漏。）</li>\n<li>全局保存的对象。像 <a href=\"https://redux.js.org/\">Redux</a> 的状态是存在全局对象下的，所以如果不加小心，可能会不断增加内存消耗，而它永远不会被清理。</li>\n<li>无尽的 DOM 增长。如果实现了一个无线滚动的功能而没有使用<a href=\"https://github.com/WICG/virtual-scroller#readme\">虚拟化</a>，那么 DOM 节点的数量会无限制的增长。</li>\n</ol>\n<p>当然还有很多其他泄漏内存的方式，以上是比较常见的类型。</p>\n<h3>鉴别内存泄漏</h3>\n<p>在 Chrome 开发者工具中，我们主要使用 “Memory tab” 下面的 “Heap snapshot”：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 570px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8f2fa0b193b0dd41794c141ad9480a38/f65ec/chrome-dev-tool.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.42105263157894%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAAB8klEQVQoz52T627aQBCF/eCV0hACRBApL9Dn6I9KfYqqlQgGXwr4tmB7zdpr7D0964QqRcmfWvo0u76cmTk7dibjz7gf3xgbJ5NbMsLk/hZj7ufzKeaLBywe53h6WuDhYYy7u5vhmWU6HWE2G5vZdGQeF1N8mY/OThzHRogDDscjikxARPGAlhVMXUNJi8L5dIJpmlf0ENGegTN5uUx2zOH8+PkLnu+b7XaL3HURk2S9QRVFqJNkQGcpydBY0vQviugoMlDKWEXf84zjrtfI8wLVqUJdFIiDAFEQYu/7JOA+RJlmKCh8TX5ZszvdtgjDEM6KFR1ZqpQSjdbIKVpyLauKSU5DIrs+KQXN9uyH1zRsv++6F8Hn1eofwexwQJSkyMsSqqkhKWqxgs1F4E1smcTSGXMlaCuKY8SbDSLaELlrJJ4PyXv2vqSnxX6PkrG0kdi9oq9tnqNj2yG/dexhFGzTVljSP2/lInU3EPTOo2jAAxIULIVA8R4UzBklxf3lEk7FygYxip6ZpdEtur4f5kDRG1t5TSt6tvQhdmY4YgG7dUp6dRHs6N9/X28FL6JVlOD3mvO49NHt6NluB8HR0Rx8w3d6JjXv0PMZDwI+J2YQLIhWEt+fK3z6KjD7JpBLtqs0VM0/w1rA1sxHvFq0p49/ADB3e6V6DyMRAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"chrome dev tool\"\n        title=\"chrome dev tool\"\n        src=\"/static/8f2fa0b193b0dd41794c141ad9480a38/f65ec/chrome-dev-tool.png\"\n        srcset=\"/static/8f2fa0b193b0dd41794c141ad9480a38/00d96/chrome-dev-tool.png 148w,\n/static/8f2fa0b193b0dd41794c141ad9480a38/0b23c/chrome-dev-tool.png 295w,\n/static/8f2fa0b193b0dd41794c141ad9480a38/f65ec/chrome-dev-tool.png 570w\"\n        sizes=\"(max-width: 570px) 100vw, 570px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>当我们点击 “Take snapshot” 按钮，在页面的 JavaScript 虚拟机上就开始捕获所有的存活对象。包括被 <code class=\"language-text\">window</code> 引用的对象，被 <code class=\"language-text\">setInterval</code> 回调函数引用的对象等。将它看作该网页使用的所有内存的停滞时刻。</p>\n<p>下一步是重现某些你认为会造成泄露的场景，例如，打开然后关闭一个对话框。一旦关闭对话框，期望内存会回到之前的水平。所以再记录一个快照，然后与之前的快照进行对比。</p>\n<p>然而，需要意识到这个工具有一些限制：</p>\n<ol>\n<li>尽管点击了 “collect garbage” 按钮，可能也需要连续几次快照才能真正清除未引用的内存。（检查每次快照的总内存，它应该保持一样稳定。）</li>\n<li>如果存在 web workers，service workers，iframes，shared workers 等。那这些内存不会出现在 heap 快照中，因为它们存在于另一个 JavaScript 虚拟机中。可以捕获这部分内存，但是要确保你知道在测量哪一部分。</li>\n<li>有时候快照会卡住或崩溃。需要关闭浏览器 tab 然后重新开始。</li>\n</ol>\n<p>看到这里，你或许会去看两个快照之间有哪些对象是被泄露了。这会变得有些棘手，因为那些对象不是所有的都是真的泄漏。许多只是正常的使用 — 有些对象会因为是被另一个对象引用而再次被分配，有些是被某种方式缓存起来在将来被清除等。</p>\n<h3>遍历 retainer 树</h3>\n<p>堆快照 diff 可以展示一个 “retainer” 链，从链上可以找出哪些对象指向其他哪些保持存活的对象。可以据此找出泄漏的对象是在哪里被创建的。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 570px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4574b346b300d67936c66ac6f03476b7/f65ec/retainer-chain.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 19.473684210526315%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAAAxUlEQVQY012OUQ6DIBBEvf8h21hRC4isCgqKTBfiV0leNpksb6cRrxbzMGASAvph6nsYzkyZD2WHxgGy69CJHoL3Pp8OUiq83m/0vKOUQmO+tgqUKJIRJCXObUPyHtfDvXusdoOWhG2UOEKA55yWBc45TJOBMTPatkUTYsJMC/RsQSyidcV13/h/mSlpZkHOGSklXFdCjJGlvlIbhtWBBgXJDRU3Ja3hrMVOhMDyyEdOltS2PE9jEFhy7EdtV5BKY+Jc898fIk0wgsBwGCkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"retainer chain\"\n        title=\"retainer chain\"\n        src=\"/static/4574b346b300d67936c66ac6f03476b7/f65ec/retainer-chain.png\"\n        srcset=\"/static/4574b346b300d67936c66ac6f03476b7/00d96/retainer-chain.png 148w,\n/static/4574b346b300d67936c66ac6f03476b7/0b23c/retainer-chain.png 295w,\n/static/4574b346b300d67936c66ac6f03476b7/f65ec/retainer-chain.png 570w\"\n        sizes=\"(max-width: 570px) 100vw, 570px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>上面例子中，有一个变量 <code class=\"language-text\">someObject</code> 被一个闭包（context）引用，实际是由一个事件监听器引用的。如果点击源代码链接，它会定位到 JavaScript 声明的地方：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeObject</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> someObject <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SomeObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> onMessage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上面例子中，“context” 就是引用了 <code class=\"language-text\">someObject</code> 变量的 <code class=\"language-text\">onMessage</code> 闭包。（这是一个<a href=\"https://github.com/nolanlawson/pinafore/commit/de6ca2d85334ad5f657ddd0f335750b60afab895\">故意的例子</a>，真实环境中的内存泄漏会比这更难以发现。）</p>\n<h3>参考</h3>\n<p><a href=\"https://nolanlawson.com/2020/02/19/fixing-memory-leaks-in-web-applications/\">https://nolanlawson.com/2020/02/19/fixing-memory-leaks-in-web-applications/</a></p>","frontmatter":{"title":"处理 Web 应用中的内存泄露问题","date":"March 01, 2020","description":"分析内存泄漏的原因,做出针对性的处理"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tags":["memory leak"],"slug":"/fixing-memory-leaks-in-web-app/","previous":{"excerpt":"背景 我之前每天都会去腾讯新闻页面上去关注有关疫情发展的当日的数据状况，久而久之就感觉该页面不够精简，而且路径过长，需要二次点击才能看到主页面。那么就干脆直接去拿他们的数据来自己做个页面好了，仓库地址：前端https://github.com/keisei77/small…","fields":{"slug":"/build-crawler-with-nextjs-and-heroku/"},"frontmatter":{"date":"March 08, 2020","description":"了解如何利用免费资源来实现微型爬虫 Web 应用并记录遇到的一些坑","title":"使用 Next.js + Puppeteer + heroku 构建爬虫 Web APP","tags":["Crawler","Next.js","Puppeteer"]}},"next":{"excerpt":"本文我们来看一下用于ECMAScript和WebAssembly的V8 引擎的内存管理。V8 引擎现在被 NodeJS，Deno 等运行时，Electron，还有 Chrome，Chromium，Brave，Opera 和 Microsoft Edge…","fields":{"slug":"/architecture-of-v8-memory/"},"frontmatter":{"date":"February 24, 2020","description":"对V8的内存管理加以了解","title":"了解 V8 内存管理","tags":["V8","Garbage Collection"]}}}}}