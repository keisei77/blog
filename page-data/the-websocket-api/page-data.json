{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/the-websocket-api/","result":{"data":{"site":{"siteMetadata":{"title":"学习随笔"}},"markdownRemark":{"id":"aad74de5-56e3-558e-b80f-df3c9f474d49","excerpt":"引言 WebSocket API 是一种较为高级的通信方式，它在客户端和服务端开启一条全双工的通道，可以从客户端发送消息至服务端并且可以接受事件驱动的响应而不需要主动去请求回复。简而言之，收发消息的两端一旦开启通道可相互自由通信。 WebSocket 客户端 为了使用 WebSocket…","html":"<h2>引言</h2>\n<p>WebSocket API 是一种较为高级的通信方式，它在客户端和服务端开启一条全双工的通道，可以从客户端发送消息至服务端并且可以接受事件驱动的响应而不需要主动去请求回复。简而言之，收发消息的两端一旦开启通道可相互自由通信。</p>\n<h2>WebSocket 客户端</h2>\n<p>为了使用 WebSocket 协议通信，需要创建 <code class=\"language-text\">WebSocket</code> 对象，会自动尝试创建到服务端的连接。</p>\n<p>WebSocket 构造函数接受两个参数：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">websocket <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebSocket</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> protocols<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">url</code></p>\n<p>    指定要连接的服务器的 URL 地址，应该以 <code class=\"language-text\">wss://</code> 协议开头，不安全的地址以 <code class=\"language-text\">ws://</code> 开头。</p>\n<p><code class=\"language-text\">protocols</code> (可选)</p>\n<p>    一个协议字符串或是多个协议字符串的数组。这些字符串用来指定子协议，可以让一个服务器实现多个 WebSocket 子协议（例如，可以通过不同的 <code class=\"language-text\">protocol</code> 来使服务器处理不同类型的交互）。如果没有指定该参数，默认为空字符串。</p>\n<p>如果地址不可访问，构造函数会抛出 <code class=\"language-text\">SecurityError</code>，通常会出现在连接不安全的地址（几乎所有的客户端都要求提供安全的 WebSocket 连接，除非在相同的设备上或在同一个网络下）。</p>\n<h3>建立连接</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> exampleSocket <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebSocket</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'wss://www.example.com/socketserver'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'protocolOne'</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 可以选择多个协议</span>\n<span class=\"token keyword\">const</span> exmapleSocket2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebSocket</span><span class=\"token punctuation\">(</span><span class=\"token string\">'wss://www.example.com/socketserver2'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token string\">'protocolOne'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'protocolTwo'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>exampleSocket 此时的 readyState 是 <code class=\"language-text\">CONNECTING</code>，一旦握手成功可以传输数据时 <code class=\"language-text\">readyState</code> 的状态变为 <code class=\"language-text\">OPEN</code> 。 <code class=\"language-text\">exampleSocket.protocol</code> 属性可以得出服务端选择的协议是哪一个。</p>\n<p>建立 WebSocket 连接需要依赖<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism\">HTTP 升级机制</a>，当我们通过 <code class=\"language-text\">ws://www.example.com</code> 或 <code class=\"language-text\">wss://www.example.com</code> 访问服务端时，实际上发生了隐式的请求升级。</p>\n<h3>发送数据至服务端</h3>\n<p>一旦建立连接，便可以通过 <code class=\"language-text\">send()</code> 方法向服务端发送 <code class=\"language-text\">string</code>， <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Blob\"><code class=\"language-text\">Blob</code></a>，<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ArrayBuffer\"><code class=\"language-text\">ArrayBuffer</code></a> 格式的数据。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'一段发送至服务器的消息...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>由于建立连接是异步并且可能会失败的，所以建立连接后立即调用 <code class=\"language-text\">send()</code> 方法是不能保证成功的。可以通过定义 <code class=\"language-text\">onopen</code> 监听函数来保证连接至少在开启后再去发送数据。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onopen</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'一段发送至服务器的消息...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4>使用 JSON 传输对象</h4>\n<p>当需要向服务端传输复杂的数据时可以用<a href=\"https://developer.mozilla.org/en/JSON\">JSON</a>包装为字符串：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">sendText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 构造服务端处理数据所需的对象结构</span>\n  <span class=\"token keyword\">const</span> msg <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    type<span class=\"token punctuation\">:</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span>\n    text<span class=\"token punctuation\">:</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'text'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span>\n    id<span class=\"token punctuation\">:</span> clientID<span class=\"token punctuation\">,</span>\n    date<span class=\"token punctuation\">:</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 发送JSON字符串</span>\n  exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>从服务端接收消息</h3>\n<p>WebSocket 是事件驱动的 API，当接收到消息，一个 <code class=\"language-text\">message</code> 事件会发送至 <code class=\"language-text\">WebSocket</code> 对象。可通过监听 <code class=\"language-text\">message</code> 事件或者定义 <code class=\"language-text\">onmessage</code> 事件句柄。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onmessage</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4>接收并解析数据</h4>\n<p>以聊天工具来说，客户端需要接收的数据包类型有：</p>\n<ul>\n<li>登录握手</li>\n<li>消息文本</li>\n<li>用户列表更新</li>\n</ul>\n<p>以下为解析即将到来的数据：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onmessage</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> f <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'chatbox'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>contentDocument<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> text <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> msg <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> time <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> timeStr <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span><span class=\"token function\">toLocaleTimeString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">:</span>\n      clientID <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span>\n      <span class=\"token function\">setUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'username'</span><span class=\"token punctuation\">:</span>\n      text <span class=\"token operator\">=</span>\n        <span class=\"token string\">'&lt;b>User &lt;em>'</span> <span class=\"token operator\">+</span>\n        msg<span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span>\n        <span class=\"token string\">'&lt;/em> signed in at '</span> <span class=\"token operator\">+</span>\n        timeStr <span class=\"token operator\">+</span>\n        <span class=\"token string\">'&lt;/b>&lt;br>'</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">:</span>\n      text <span class=\"token operator\">=</span> <span class=\"token string\">'('</span> <span class=\"token operator\">+</span> timeStr <span class=\"token operator\">+</span> <span class=\"token string\">') &lt;b>'</span> <span class=\"token operator\">+</span> msg<span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">'&lt;/b>: '</span> <span class=\"token operator\">+</span> msg<span class=\"token punctuation\">.</span>text <span class=\"token operator\">+</span> <span class=\"token string\">'&lt;br>'</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'rejectusername'</span><span class=\"token punctuation\">:</span>\n      text <span class=\"token operator\">=</span>\n        <span class=\"token string\">'&lt;b>Your username has been set to &lt;em>'</span> <span class=\"token operator\">+</span>\n        msg<span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span>\n        <span class=\"token string\">'&lt;/em> because the name you chose is in use.&lt;/b>&lt;br>'</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'userlist'</span><span class=\"token punctuation\">:</span>\n      <span class=\"token keyword\">const</span> ul <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> msg<span class=\"token punctuation\">.</span>users<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ul <span class=\"token operator\">+=</span> msg<span class=\"token punctuation\">.</span>users<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token string\">'&lt;br>'</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'userlistbox'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> ul<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    f<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'chatbox'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>contentWindow<span class=\"token punctuation\">.</span><span class=\"token function\">scrollByPages</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里我们通过 <code class=\"language-text\">JSON.parse()</code> 来将字符串数据解析为对象格式，并执行对应逻辑。</p>\n<h4>文本格式</h4>\n<p>通过 WebSocket 接收的文本为 UTF-8 格式。</p>\n<h3>关闭连接</h3>\n<p>当完成通信断开连接时通过调用 <code class=\"language-text\">close()</code> 方法来实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>在关闭连接时最好检查 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/bufferedAmount\"><code class=\"language-text\">bufferedAmount</code></a> 在网路中是否还有未传输的数据。如果值不为 0，说明还有数据待处理，所以需要处理完成再关闭。</p>\n<h3>安全事项</h3>\n<p>WebSocket 不应该在混合环境中使用。即不能在 HTTPS 中建立不安全的 WebSocket，反之亦然。\n现在大多数浏览器厂商只允许安全的 WebSocket 连接，不再支持在不安全的环境下使用。</p>\n<h2>WebSocket 服务端</h2>\n<p>简单来说一个 WebSocket 服务器是监听任何 TCP 服务器端口的应用程序。实现一个自定义的服务器听起来让人畏却，但实际上实现一个简单的 WebSocket 是非常容易的。</p>\n<p>可以使用任何支持<a href=\"https://en.wikipedia.org/wiki/Berkeley_sockets\">Berkeley sockets</a>的服务端语言来编写一个 WebSocket 服务器，例如 C(++)，Python，PHP，或者<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Server-Side_JavaScript\">服务端 JavaScript</a>。</p>\n<p>WebSocket 服务器通常是独立的专门的服务器（为了负载均衡或其他实际的原因），所以需要使用<a href=\"https://en.wikipedia.org/wiki/Reverse_proxy\">反向代理</a>来检测 WebSocket 握手，预处理，并将客户端发送至真正的 WebSocket 服务器。这意味着不需要在服务器程序中处理 cookie 和鉴权等操作。</p>\n<h3>WebSocket 握手</h3>\n<p>首先，服务器必须使用一个标准的 TCP 套接字来监听即将到来的 socket 连接。在 WebSocket 中握手就是 <code class=\"language-text\">Web</code> 。它是从 HTTP 到 WebSockets 的桥梁。在握手过程中，连接协商过程中，如果条款是有问题的，任何一方都可以在连接成功之前退出。服务器必须小心理解任何客户端的请求，否则就会出现安全问题。</p>\n<h4>客户端握手请求</h4>\n<p>客户端握手过程通过连接服务器并且发送一个 WebSocket 连接请求。<code class=\"language-text\">client</code> 会发送一个标准的带有头部的 HTTP 请求（HTTP 版本必须 1.1 或更高，方法必须是 <code class=\"language-text\">GET</code> 请求）。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET /chat HTTP/1.1\nHost: example.com:8000\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13</code></pre></div>\n<p>客户端可以征求扩展或子协议。一些其他常见的头信息<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent\">User-Agent</a>，<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer\">Referer</a>，<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie\">Cookie</a> 或权限校验等也需要发送。它们并非与 WebSocket 直接关联，并且可以安全地忽略。通常来说反向代理会首先处理这些头信息。</p>\n<p>如果 header 中有任一信息有误，服务器会发出 <code class=\"language-text\">400</code> 的状态码并立即关闭 socket。</p>\n<h4>服务器握手响应</h4>\n<p>当服务器收到握手请求，会返回一个特殊的响应来指明协议会从 HTTP 变更为 WebSocket。头信息大致如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</code></pre></div>\n<p>此外，服务器可以决定扩展/子协议的请求。<code class=\"language-text\">Sec-WebSocket-Accept</code> 是根据从客户端的 <code class=\"language-text\">Sec-WebSocket-Key</code> 来生成的。具体规则为将 <code class=\"language-text\">Sec-WebSocket-Key</code> 和<a href=\"https://en.wikipedia.org/wiki/Magic_string\">魔法字符串</a> <code class=\"language-text\">258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code> 拼接至一起，然后执行 <a href=\"https://en.wikipedia.org/wiki/SHA-1\">SHA-1 hash</a>，最后返回该哈希 <a href=\"https://en.wikipedia.org/wiki/Base64\">base64</a>的编码格式。</p>\n<p>一旦服务端发送这些头信息，说明握手已经成功，可以交换数据。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">在发送握手的响应之前服务器可以发送其他头信息，或要求鉴权，或者通过其他状态码重定向到其他服务器。</code></pre></div>\n<h4>保持客户端连接</h4>\n<p>这并不直接与 WebSocket 协议关联，但值得提出：服务器需要保持客户端 socket 的连接，这样就不需要在完成握手后再次握手。</p>\n<h3>交换数据帧</h3>\n<p>服务端和客户端任一者可以选择在任何时候发送消息。</p>\n<h4>格式化</h4>\n<p>每个数据帧都需要遵循如下格式：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Frame format:\n​​\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-------+-+-------------+-------------------------------+\n    |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n    |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n    |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n    | |1|2|3|       |K|             |                               |\n    +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n    |     Extended payload length continuedundefined if payload len == 127  |\n    + - - - - - - - - - - - - - - - +-------------------------------+\n    |                               |Masking-keyundefined if MASK set to 1  |\n    +-------------------------------+-------------------------------+\n    | Masking-key (continued)       |          Payload Data         |\n    +-------------------------------- - - - - - - - - - - - - - - - +\n    :                     Payload Data continued ...                :\n    + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n    |                     Payload Data continued ...                |\n    +---------------------------------------------------------------+</code></pre></div>\n<p>MASK 位表明了信息是否是编码的。信息从客户端发出时必须是加密的，服务端期望收到的值为 1，而服务端发送的数据不会加密，也不会设置 MASK 位。</p>\n<p>opcode 字段定义了如何解析数据载荷：0x0 表示继续，0x1 表示 UTF-8 格式的文本，0x2 表示二进制等。</p>\n<p>FIN 位表明是否是该数据流的最后一条信息。如果为 0，服务器会保持收听信息的其他部分，如果为 1 则认为信息已送达。</p>\n<h4>解码载荷长度</h4>\n<p>为了读取载荷数据需要知道何时停止读取，所以知道载荷长度非常重要：</p>\n<ol>\n<li>读取 9-15 位并解析为无符号整数。如果小于等于 125，那么该值就是数据长度。如果等于 126，执行第二步。如果等于 127，执行第三步。</li>\n<li>读取接下来的 16 位并解析为无符号整数，完成。</li>\n<li>读取接下来 64 位解析为无符号整数（最高位必须位 0），完成。</li>\n</ol>\n<h4>读取并解密数据</h4>\n<p>如果设置了 MASK 位，需要读后面 4 组 8 位，这是编码的 key。一旦载荷长度和编码 key 解析完成，可以继续从 socket 中读取该长度的字节数。为了解码，循环遍历加密数据的八位字节（文本数据的字节），然后将八位字节与 MASK 的第（i 模 4）个八位字节进行 XOR 运算。伪代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> <span class=\"token constant\">DECODED</span> <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">ENCODED</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token constant\">DECODED</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token constant\">ENCODED</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">^</span> <span class=\"token constant\">MASK</span><span class=\"token punctuation\">[</span>i <span class=\"token operator\">%</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>消息片段</h4>\n<p>FIN 和 opcode 字段在一起将发送的一条信息拆分为多个单独的帧。被称为<code class=\"language-text\">message fragmentation</code>。碎片化（Fragmentation）只在 opcode 的 <code class=\"language-text\">0x0</code> 至 <code class=\"language-text\">0x2</code> 有效。</p>\n<ul>\n<li>0x0：代表一个连续帧，意味着需要把该帧的数据载荷和上一帧的载荷连接在一起</li>\n<li>0x1：代表载荷为文本格式</li>\n<li>0x2：代表载荷为二进制格式</li>\n</ul>\n<p>下面是一个简单的例子来说明服务端是如何响应客户端信息的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Client: FIN=1undefined opcode=0x1undefined msg=&quot;hello&quot;\nServer: (process complete message immediately) Hi.\nClient: FIN=0undefined opcode=0x1undefined msg=&quot;and a&quot;\nServer: (listeningundefined new message containing text started)\nClient: FIN=0undefined opcode=0x0undefined msg=&quot;happy new&quot;\nServer: (listeningundefined payload concatenated to previous message)\nClient: FIN=1undefined opcode=0x0undefined msg=&quot;year!&quot;\nServer: (process complete message) Happy new year to you too!</code></pre></div>\n<p>第一帧包含了全部的消息，所以服务端可以处理并响应。第二帧客户端发送了文本载荷但整个信息并没有完全送达，其他剩余部分通过连接帧来发送，通过标记<code class=\"language-text\">FIN=1</code>指明了最后一帧。</p>\n<h3>Pings and Pongs: WebSocket 心跳检测</h3>\n<p>在握手完成后，客户端或服务端都可以选择发送一个 ping 至对方，当 ping 收到时，接收方必须尽快发送一个 pong 给对方。可以通过这个机制来确认对方是否仍在连接。</p>\n<p>一个 ping 或 pong 只是一个普通的控制帧，Pings 的 opcode 为 <code class=\"language-text\">0x9</code> ，pongs 的 opcode 为 <code class=\"language-text\">0xA</code>。当收到一个 ping，发送 pong 时携带 ping 发送的一致的数据载荷（最大载荷长度为 125）。</p>\n<h3>关闭连接</h3>\n<p>客户端或服务端关闭连接可以发送一个带有包含一个特殊控制序列数据的控制帧来开启关闭握手。接收到此帧后，另一方会发送一个结束帧作为响应。先前的一方会关闭连接。关闭连接后收到的任何其他数据都会被丢掉。</p>\n<h2>参考</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Websockets_API\">https://developer.mozilla.org/en-US/docs/Web/API/Websockets_API</a></p>","frontmatter":{"title":"The WebSocket API","date":"November 26, 2019","description":"本文主要介绍web应用中Socket编程的相关技术，包括如何实现简单的Socket客户端和服务器"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tags":["WebSocket"],"slug":"/the-websocket-api/","previous":{"excerpt":"背景 最近在个人博客中采用了styled-components库来写组件的样式，在翻看文档时，发现用法： 这个用法引起了我的兴趣，这是如何 work 起来的？ 带标签的模板字符串（Tagged Template Literals…","fields":{"slug":"/tagged-template-literals/"},"frontmatter":{"date":"December 01, 2019","description":"本文主要介绍了ES6的模板字符串的高级用法","title":"神奇的模板字符串","tags":["Template Literals","ES6"]}},"next":{"excerpt":"介绍 React Fiber 是当前开发中的最新版 React…","fields":{"slug":"/react-fiber-architecture/"},"frontmatter":{"date":"November 22, 2019","description":"本文主要介绍 React 新的架构设计-- Fiber , 将能使 React 可对渲染过程进行资源调度，最大化提高用户体验","title":"React Fiber 架构","tags":["React","Fiber","Architecture","diff"]}}}}}