{"componentChunkName":"component---src-pages-index-tsx","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"excerpt":"前言 之前曾有打算做一个富文本编辑器，最近花了一些时间开始开发，目前处于原型开发阶段。这其中遇到了一些棘手的问题，在此先记录一下。 初步构建 通过 CRA（create-react-app…","fields":{"slug":"/mini-editor/"},"frontmatter":{"date":"April 14, 2020","title":"迷你富文本编辑器","description":"手撸富文本编辑器遇到的问题及参考思路"}}},{"node":{"excerpt":"对于前端开发者来说，除 API…","fields":{"slug":"/what-frontend-developer-should-know-about-banckend/"},"frontmatter":{"date":"March 15, 2020","title":"前端开发人员应该知道的后端知识","description":"本文主要介绍一些前端应该知道的后端知识点。"}}},{"node":{"excerpt":"本文来介绍一些能够使 Web…","fields":{"slug":"/performant-frontend-architecture/"},"frontmatter":{"date":"March 12, 2020","title":"高性能前端架构","description":"本文将从几个方面来介绍如何构建高性能架构"}}},{"node":{"excerpt":"背景 我之前每天都会去腾讯新闻页面上去关注有关疫情发展的当日的数据状况，久而久之就感觉该页面不够精简，而且路径过长，需要二次点击才能看到主页面。那么就干脆直接去拿他们的数据来自己做个页面好了，仓库地址：前端https://github.com/keisei77/small…","fields":{"slug":"/build-crawler-with-nextjs-and-heroku/"},"frontmatter":{"date":"March 08, 2020","title":"使用 Next.js + Puppeteer + heroku 构建爬虫 Web APP","description":"了解如何利用免费资源来实现微型爬虫 Web 应用并记录遇到的一些坑"}}},{"node":{"excerpt":"当我们从构建服务端渲染的网站切换到构建客户端渲染的单页面应用时，我们需要对用户设备上的资源格外小心。不能阻碍 UI…","fields":{"slug":"/fixing-memory-leaks-in-web-app/"},"frontmatter":{"date":"March 01, 2020","title":"处理 Web 应用中的内存泄露问题","description":"分析内存泄漏的原因,做出针对性的处理"}}},{"node":{"excerpt":"本文我们来看一下用于ECMAScript和WebAssembly的V8 引擎的内存管理。V8 引擎现在被 NodeJS，Deno 等运行时，Electron，还有 Chrome，Chromium，Brave，Opera 和 Microsoft Edge…","fields":{"slug":"/architecture-of-v8-memory/"},"frontmatter":{"date":"February 24, 2020","title":"了解 V8 内存管理","description":"对V8的内存管理加以了解"}}},{"node":{"excerpt":"笔者之前接手过一些小程序的项目，不过当时时间紧任务重，基本上就是边看文档边撸代码，并没有真正好好的理解小程序的设计。今天准备花些时间来了解一下，小程序背后的故事。 前世今生 小程序这个概念应该是微信最早提出并推广应用的。当时发布之后我也尝试做过类似 Instagram…","fields":{"slug":"/architecture-of-miniprogram/"},"frontmatter":{"date":"February 23, 2020","title":"初识小程序架构","description":"本文以微信小程序为例，来了解微信小程序的架构和底层实现原理"}}},{"node":{"excerpt":"React Native 是一个能够允许 JavaScript 和 native 代码一样在 iOS 和 Android 设备上运行和交互的现代框架。它提供了一种编写一次多端运行的能力，有机会使我们统一应用的架构。对于新手而言了解 RN…","fields":{"slug":"/architecture-of-rn/"},"frontmatter":{"date":"February 22, 2020","title":"初识 React Native 架构","description":"对RN架构有一个整体的了解，原文章可能已过时但核心原理应该是不变的。"}}},{"node":{"excerpt":"从理念上来说，Koa 意图“修复并取代 node”，而 Express 做的是“增强 node”。Koa 使用 promise 和 async 函数来摆脱回调地狱并简化异常处理逻辑。它暴露了自身的  和  对象而取代了 node 的  和  对象。 Express…","fields":{"slug":"/koa-vs-express/"},"frontmatter":{"date":"February 20, 2020","title":"Koa 对比 Express","description":"Koa 与 Express 有哪些异同之处"}}},{"node":{"excerpt":"web 开发者想必都一定听说过 express.js。Express 是 node 中比较受欢迎的轻量的 web 服务器框架。 本文我们将通过分析 express…","fields":{"slug":"/how-expressjs-works/"},"frontmatter":{"date":"February 14, 2020","title":"Express.js 工作原理","description":"Express.js 工作原理，部分源码分析"}}},{"node":{"excerpt":"当前已经有很多的文章或会议中谈到了服务端渲染这种技术。而且社区中也出现了许多一站式的 React 框架，但是真正想要了解服务端渲染还是需要自己动手实现一下比较好。不过首先我们需要了解什么是服务端渲染和客户端渲染。 JavaScript 革命 浏览器比 5-1…","fields":{"slug":"/react-ssr/"},"frontmatter":{"date":"February 09, 2020","title":"React SSR 初体验","description":"SSR 的入门学习"}}},{"node":{"excerpt":"generator 函数不同于通常的函数，运行就结束。我们可以任意暂停函数的执行，并在合适时机输出。 通过在  关键字后面添加  创建 generator 函数。 generator 函数与普通函数实际上工作方式完全不同： 调用 generator…","fields":{"slug":"/javascript-visualized-generator-function/"},"frontmatter":{"date":"February 05, 2020","title":"JavaScript 可视化之迭代器和迭代函数","description":"迭代器和迭代函数以图形化的方式展示，方便理解"}}},{"node":{"excerpt":"当我们对字符串，数组或对象使用内置的方法或属性如 ，， 等时，这是通过 原型继承（prototypal inheritance…","fields":{"slug":"/javascript-visualized-prototypal-inheritance/"},"frontmatter":{"date":"February 04, 2020","title":"JavaScript 可视化之原型继承","description":"原型继承以图形化的方式展示，方便理解"}}},{"node":{"excerpt":"作为 JavaScript 开发人员，我们有必要了解关于 JavaScript 引擎的基础，它是如何将 JS 代码编译成机器码的。以下内容会以 V8 引擎为主。 HTML 解析器当遇到  标签时，源代码会从该 source 路径从网络，缓存或者安装的 service worker…","fields":{"slug":"/javascript-visualized-engine/"},"frontmatter":{"date":"February 03, 2020","title":"JavaScript 可视化之执行引擎","description":"执行引擎以图形化的方式展示，方便理解"}}},{"node":{"excerpt":"本文假设读者已了解执行上下文的基本概念。 我们首先来看以下代码： 我们调用  函数时，返回了一串包含 ,  和  变量的字符串：。但是  函数内并没有声明变量 `city，它是怎么得到的呢？ JavaScript…","fields":{"slug":"/javascript-visualized-scope/"},"frontmatter":{"date":"February 01, 2020","title":"JavaScript 可视化之作用域链","description":"作用域链以图形化的方式展示，方便理解"}}},{"node":{"excerpt":"什么是变量提升？ 从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。(MDN) 提升的对象是定义的变量或函数（Declarations…","fields":{"slug":"/javascript-visualized-hoisting/"},"frontmatter":{"date":"January 28, 2020","title":"JavaScript 可视化之变量提升","description":"变量提升以图形化的方式展示，方便理解"}}},{"node":{"excerpt":"事件循环大概是每个 JavaScript 初学者都会感到困惑的概念。本文将通过可视化的方式来尽量对该概念作详细的解释。 我们来首先了解一下什么是事件循环，以及我们为什么要关心它？ JavaScript…","fields":{"slug":"/javascript-visualized-event-loop/"},"frontmatter":{"date":"January 25, 2020","title":"JavaScript 可视化之事件循环","description":"事件循环以图形化的方式展示，方便理解"}}},{"node":{"excerpt":"2019年平平淡淡的就这么度过了，本身没有太多值得回顾的，但是自从没有坚持继续记日记之后，好久没有花时间好好自我反省过了。 工作 全年主要在公司承担业务UI改版的工作，期间并没有亮眼的成绩，反而还造成了一些由于业务不熟悉导致的bug…","fields":{"slug":"/annual-summary/"},"frontmatter":{"date":"January 22, 2020","title":"2019年末总结","description":"年末总结与回顾"}}},{"node":{"excerpt":"写了这么久的 React，你或许对虚拟 DOM 是怎么工作的感到好奇，本文将通过解读部分  和  源码来尝试作详细的解释。在开始前，你是否考虑过为什么我们不是直接对 DOM 进行修改？  接下来的章节将总结一下 DOM 是如何被创建的，并给出为什么 React…","fields":{"slug":"/react-virtual-dom-and-diff/"},"frontmatter":{"date":"January 19, 2020","title":"虚拟DOM和diff算法在React中的工作方式","description":"本文主要介绍React中的虚拟DOM和diff算法是如何工作的，以及部分源码解读"}}},{"node":{"excerpt":"最近在看 Redux 文档，了解了 redux 的工作原理，发现 action 只能同步被 dispatch，那有没有办法执行异步调用呢？答案是通过中间件来实现。之前简单了解过 Node.js 服务端框架 Express 和 Koa…","fields":{"slug":"/understanding-the-middleware/"},"frontmatter":{"date":"January 12, 2020","title":"了解中间件","description":"了解中间件的概念"}}},{"node":{"excerpt":"React Hooks 在 React 16.7 版本发布后，在社区掀起了一股新的浪潮，真的是谁用谁都说真香。刚使用 Hooks 时难免会对该机制的原理感到神奇，在遇到问题时，由于它背后复杂的调用栈我们很难进行调试，所以有必要更深层次了解 React Hooks…","fields":{"slug":"/unveil-react-hooks-system/"},"frontmatter":{"date":"January 08, 2020","title":"浅析 React Hooks","description":"本文对目前大热的 React Hooks 源码进行简单剖析。"}}},{"node":{"excerpt":"什么是装饰器 装饰器是“装饰函数（或方法）”的一种简称。它是一个通过修改传入的函数或方法的行为并返回一个新函数的函数。 我们可以在任何支持函数为一等公民的语言中实现装饰器，如 JavaScript…","fields":{"slug":"/understanding-javascript-decorators/"},"frontmatter":{"date":"January 05, 2020","title":"JavaScript 装饰器","description":"JavaScript 装饰器入门介绍"}}},{"node":{"excerpt":"简述 Docker 是集开发、发布、执行应用功能的一个开放平台。Docker 能够帮我们将应用和基础设施分离来达到更快的交付。有了 Docker，我们可以像管理基础设施一样管理我们的软件。有了 Docker…","fields":{"slug":"/docker-overview/"},"frontmatter":{"date":"December 30, 2019","title":"Docker 简介","description":"Docker 简介，Docker 能做什么以及底层原理"}}},{"node":{"excerpt":"模板打包器把小的代码片段转译成可在浏览器中运行的更大更复杂的文件。这些代码片段都是 JavaScript 文件，所有代码间的依赖都由模块系统来表示（https://webpack.js.org/concepts/modules…","fields":{"slug":"/minipack/"},"frontmatter":{"date":"December 25, 2019","title":"迷你打包工具","description":"精简版打包工具，领略内部实现之巧"}}},{"node":{"excerpt":"简介 前一节我们介绍了浏览器从地址栏输入 URL 开始内部是如何工作的。本文来看一下渲染器进程内部是如何工作的，由于该部分涉及到了 web 优化的众多方面，本文尽量以高度概括的方式进行讲解，如需进一步学习可访问 Web 基础之性能优化。 渲染器进程处理 web…","fields":{"slug":"/web-browser-render/"},"frontmatter":{"date":"December 18, 2019","title":"渲染器进程的内部执行","description":"渲染器进程的内部执行过程"}}},{"node":{"excerpt":"前言 我们知道现在市场上大多数浏览器是多进程多线程的方式来处理不同的任务。我们今天来看一下进程和线程是如何合作来呈现一个网站的。 我们以简单的浏览网页为例：从地址栏中输入 URL…","fields":{"slug":"/web-browser-happen-in-navigation/"},"frontmatter":{"date":"December 15, 2019","title":"浏览器输入URL...","description":"浏览器地址栏输入URL会做哪些事情？"}}},{"node":{"excerpt":"前言 作为 Web 开发人员，我们在工作中可能会接触移动端 Web…","fields":{"slug":"/css-resolution-vs-device-resolution/"},"frontmatter":{"date":"December 14, 2019","title":"区分CSS 分辨率和设备分辨率","description":"CSS中的像素和设备分辨率像素的区分"}}},{"node":{"excerpt":"参考 https://www.youtube.com/watch?v=4GpwM8FmVgQ","fields":{"slug":"/promise-from-scratch/"},"frontmatter":{"date":"December 08, 2019","title":"简单的Promise实现","description":"No BB, show me the code."}}},{"node":{"excerpt":"简介 现代化的前端应用离不开打包工具，从早期人们所熟知的 Grunt, Gulp 到现在炙手可热的 webpack, rollup 等，这些工具的崛起使得我们的代码构建更加方便，通过 Loader，插件等机制我们可以应用最新的技术，如新语法，预处理 CSS（Scss, Less…","fields":{"slug":"/webpack-behind-the-scene/"},"frontmatter":{"date":"December 04, 2019","title":"webpack 基本原理","description":"本文主要介绍了对webpack的初步认识以及内部的工作原理。"}}},{"node":{"excerpt":"背景 最近在个人博客中采用了styled-components库来写组件的样式，在翻看文档时，发现用法： 这个用法引起了我的兴趣，这是如何 work 起来的？ 带标签的模板字符串（Tagged Template Literals…","fields":{"slug":"/tagged-template-literals/"},"frontmatter":{"date":"December 01, 2019","title":"神奇的模板字符串","description":"本文主要介绍了ES6的模板字符串的高级用法"}}},{"node":{"excerpt":"引言 WebSocket API 是一种较为高级的通信方式，它在客户端和服务端开启一条全双工的通道，可以从客户端发送消息至服务端并且可以接受事件驱动的响应而不需要主动去请求回复。简而言之，收发消息的两端一旦开启通道可相互自由通信。 WebSocket…","fields":{"slug":"/the-websocket-api/"},"frontmatter":{"date":"November 26, 2019","title":"The WebSocket API","description":"本文主要介绍web应用中Socket编程的相关技术，包括如何实现简单的Socket客户端和服务器"}}},{"node":{"excerpt":"介绍 React Fiber 是当前开发中的最新版 React…","fields":{"slug":"/react-fiber-architecture/"},"frontmatter":{"date":"November 22, 2019","title":"React Fiber 架构","description":"本文主要介绍 React 新的架构设计-- Fiber , 将能使 React 可对渲染过程进行资源调度，最大化提高用户体验"}}},{"node":{"excerpt":"JavaScript 引擎管道 当加载到我们所写的 JavaScript 代码，JavaScript 引擎开始解析源代码，并把它转换成抽象语法树（AST）。基于 AST，解释器开始工作并转换成字节码。此时引擎开始真正执行我们的 JavaScript 代码。 js engine…","fields":{"slug":"/V8-shapes-and-inline-cache/"},"frontmatter":{"date":"November 18, 2019","title":"JavaScript 引擎基础：Shapes 和 Inline Caches","description":"了解 JavaScript 引擎基本的工作原理，可以帮助我们写出更加高性能的代码。"}}},{"node":{"excerpt":"JavaScript 类型 JavaScript 的值总共具有 8 种不同的类型： 可以通过  关键字来校验值的类型。 尽管  有着它自身的一种类型，但  却返回  而不是  。为了理解原因，我们首先把所有的类型分为两组： object (即  类型) primitives…","fields":{"slug":"/V8-performance-cliff/"},"frontmatter":{"date":"November 14, 2019","title":"React源码中导致V8性能断崖下滑的真相","description":"本文主要讲述了V8如何在内存中表示JavaScript类型，并且是如何影响Shape机制的，这将会为我们解释近期发现的一个React核心代码中的性能问题。"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}