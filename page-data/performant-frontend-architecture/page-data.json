{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/performant-frontend-architecture/","result":{"data":{"site":{"siteMetadata":{"title":"学习随笔"}},"markdownRemark":{"id":"4a145b8f-8f3d-5be8-88be-09fb915a61a7","excerpt":"本文来介绍一些能够使 Web…","html":"<p>本文来介绍一些能够使 Web 应用加载更快，用户体验更好的技术。</p>\n<p>从整个前端架构来看，如何能够第一时间加载最需要的资源，最大化利用已经缓存过的资源？</p>\n<p>在此我们不会阐述过多如何优化渲染时间以及后端应如何分发资源。</p>\n<h3>概览</h3>\n<p>我们将应用的加载分为三个不同的阶段：</p>\n<ol>\n<li>初始化渲染 - 在用户看到任何画面之前需要加载多长时间？</li>\n<li>应用加载 - 在用户能够使用之前需要加载多长时间？</li>\n<li>下一页 - 在跳转到下一页时需要加载多长时间？</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1013e5a81986030631b526b79fec099b/16662/performant-front-end-architecture.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.61900756938603%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAADMUlEQVQ4y12TTW/jVBSGu2MLC8SKpvGN7ThxHDt27PgjSRM7dpp+JOnnpE3TJGSatFMJhmEQGoHECglpVvwDdoxYsoI9K/4LErBi9XKuE6aIxaNzzq366D0311tMKUOzXBh2gHLVT+HzunrQ6dxwgrQXiwZyBf0t7H/kyLXFhV6zg7B7iFa8j0bYRTs5QEi0Or20xr0+2vQ3/g+CXKKqgeU15P4LPyNpKmSVAJa3i6AVQ6d0As360QSl3iW0/asNl6gOZ1C6IwjhKVh0BhZyqO9cgHlJKk6FolqBfPwAZfUa4tESSn0P/uILeNPPEMw/hz97CX/+Eu70BcTBLbKHC7D+U7AjDvXDFVhrSMIStnKb3d8zu3jHPce7eoRCvUsSkt08hzv5BMH005TiyRLyYAGpT5LDOTEDO5itpc3+o5DfB5NVSEoJYr4I2QlhDRewBjOY/RnVOUzqK5veOJoi2z6ndWnVkGo0AnO7jyvnqzVYbh0F3cY2K0C0bKhxhGLUhtoJUQhbUKMwpURzOe6k59nAA2v4lC4As531ryxSwkzJwOjjL/Hzr7/h629eQ2rU4T9M4d9N0Hg2Q/1+Cm81SQmo53Pj2RTq5ATZsz0IowMI8e46oaQa+GBbwsnDV/j9j7/w5oc3yAU+grsbuIurNU+vUFtcpvDZ+WhE/RWkCxKddCGc9yBEzceV+T3ypLwXRBXKbhPOcowaiWySeMtrmPMLVEnk3o7hU9LieIid0y7YGcme7NPT2STkMoGL+HvkUlmDVKd3Ob2AeX2GyvUpzMk5LILP2UGM7DDBziBBhvpMv4PMcYJsq07CzZdSLllQaHVBKuBDlodarKCuu6gbXkpQrr2tnuagVrRgSTrsfAXVvAGHKCsGBdoI1YKB49sXePXd9zhePkdQsPDg7eHe72HpJFjVEtzTvHRi3NHzWFEdyzWMBBNPiHHWREesIMuFMiV7PyPh5tW3+PNv4MeffoGmmtgLOuh4IWKvjdiPkNAc+3wOEdFZQBtUZZ0wYBNaXl8nTO+QLrNoutiNEtheE5JmokjfdN6wUaCqVJy0l/ls1iBqFrbpq9ghwb/wdDlFxz9zOgjg7n6LpgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"performant frontend architecture\"\n        title=\"performant frontend architecture\"\n        src=\"/static/1013e5a81986030631b526b79fec099b/799d3/performant-front-end-architecture.png\"\n        srcset=\"/static/1013e5a81986030631b526b79fec099b/00d96/performant-front-end-architecture.png 148w,\n/static/1013e5a81986030631b526b79fec099b/0b23c/performant-front-end-architecture.png 295w,\n/static/1013e5a81986030631b526b79fec099b/799d3/performant-front-end-architecture.png 590w,\n/static/1013e5a81986030631b526b79fec099b/2a3d6/performant-front-end-architecture.png 885w,\n/static/1013e5a81986030631b526b79fec099b/ae92f/performant-front-end-architecture.png 1180w,\n/static/1013e5a81986030631b526b79fec099b/16662/performant-front-end-architecture.png 2378w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>初始渲染</h3>\n<p>在浏览器初始渲染之前用户看不到任何东西。渲染页面至少需要加载 HTML 文档，而且大多数还需要加载额外的资源，如 CSS 和 JavaScript 文件。一旦这些资源可用，浏览器开始在屏幕上渲染画面。</p>\n<p>网站的请求瀑布流大概如下：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/36a970f6e3069679776958e6e0ef10d8/c96f1/gov-uk-initial-render.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.954598370197903%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAAA+klEQVQY0yWQwW6CQBRF/f8/abpp0mU3TVdaU4u2KTIjwsCM6AhKQUCgyenUrk5ect/JzZ0Yraiqisulpu97hmFgHEf66xV9KsltTKMt511L3vSYvXXZC13X0TTNjW3TUrcVp7JgEm+XRHHCeu1jjEEphZTyxq3JONuU2ljKKMf4krfgi3z1hH3RqFAR6oD8UFDUR46VZRLKBbFK8X2fOI4RQrD0PHzH2t3MXhnnM36iDaP3TrUXlPM79L0kmAo+9JQgWbFx4uyw+2+YJJogCBwTwjC8yYVrWWQZQ5pydeLOzdLlBd/HiHLxgHncop5T/v7X8pMwExyKPb+VySUXRnzFrgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"gov uk initial render\"\n        title=\"gov uk initial render\"\n        src=\"/static/36a970f6e3069679776958e6e0ef10d8/799d3/gov-uk-initial-render.png\"\n        srcset=\"/static/36a970f6e3069679776958e6e0ef10d8/00d96/gov-uk-initial-render.png 148w,\n/static/36a970f6e3069679776958e6e0ef10d8/0b23c/gov-uk-initial-render.png 295w,\n/static/36a970f6e3069679776958e6e0ef10d8/799d3/gov-uk-initial-render.png 590w,\n/static/36a970f6e3069679776958e6e0ef10d8/c96f1/gov-uk-initial-render.png 859w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>这个 HTML 文档加载了大量额外的文件，一旦加载完成页面开始渲染。注意到 CSS 文件是并行加载的，所以每个新的请求不会增加非常明显的延迟。</p>\n<p>（gov.uk 现在启用了<a href=\"https://twitter.com/TheRealNooshu/status/1225403389158227971\">HTTP/2</a>，所以当前域名下的资源可以重新利用现有的连接。）</p>\n<h4>减少阻塞渲染的请求</h4>\n<p>样式文件和（默认）脚本元素会阻塞渲染任何在它们下面的内容。</p>\n<p>可以有几种方式来解决：</p>\n<ul>\n<li>在 body 最底部放置 script 标签</li>\n<li>通过 <code class=\"language-text\">async</code> 来异步加载脚本</li>\n<li>如果需要同步加载可以通过 inline 方式拆入 JS 或 CSS 片段</li>\n</ul>\n<h4>避免阻塞渲染的顺序请求链</h4>\n<p>网站加载慢与阻塞渲染的请求数量关系不是特别大，更重要的是每个资源的文件大小，并且浏览器何时去加载该资源。</p>\n<p>如果浏览器发现它在另一个请求完成后才需要加载某文件，这就形成了一个同步请求链。可能会有几种原因：</p>\n<ul>\n<li>CSS 中使用了 @import</li>\n<li>在 CSS 文件中引用了 Web 字体</li>\n<li>JavaScript 注入了链接或 script 标签</li>\n</ul>\n<p>可以看下面的例子：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ebea1be44487e800d63034b7fb2e9b79/5a757/circle-ci-request-chain.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.994082840236686%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABaElEQVQY0x2R226bUBBF+f8/qfoapVJbVYkUtU+xoQVsOMHmajA2twMYc4lWj3nYmpFGWqO9t9Y0kq7r6PueaZpYloXPz4VStqSJTyVyzqeG7FqS5zlN0yBbuc6H6rpG1i3nImQYW7QkSRHCxfd9kiQhTVOyhy5X8jRGBiVV3iHSnH/vfyg2AWnok2UZXdtxu/WMw0xaODQyRwujBMsyORwOHI9HTNNkv98TRxHDfaSf7ozjnaJvCTY/ib947N72WJFOFId0ytkwLGSVi7xd0fwgwjB0PM9bgbquY9s2B7UPfcdQVgzK/l1WtMcN121A5ofs3HeE6VEWp/WWXj6QXaGAvgIqiBBiBRqGwU4BgzhmPp9Znp9ZXl+ZX16Yn56YHVM9uFBvfyO+/iX5tcW33xCujWwqtFhl6DiOsm0RBMGaYStVUcPApEp4AOcf31m+KbDrMtcNo8pOnmKCyCK3XXa+zYfnrnn+B37WuSfm4zkRAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"circle ci request chain\"\n        title=\"circle ci request chain\"\n        src=\"/static/ebea1be44487e800d63034b7fb2e9b79/799d3/circle-ci-request-chain.png\"\n        srcset=\"/static/ebea1be44487e800d63034b7fb2e9b79/00d96/circle-ci-request-chain.png 148w,\n/static/ebea1be44487e800d63034b7fb2e9b79/0b23c/circle-ci-request-chain.png 295w,\n/static/ebea1be44487e800d63034b7fb2e9b79/799d3/circle-ci-request-chain.png 590w,\n/static/ebea1be44487e800d63034b7fb2e9b79/5a757/circle-ci-request-chain.png 676w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>该网站 CSS 文件中使用了 @import 来加载 google 字体，就意味着浏览器需要从一个文件请求另一个文件：</p>\n<ol>\n<li>HTML 文档</li>\n<li>应用 CSS</li>\n<li>谷歌字体 CSS</li>\n<li>谷歌字体 Woff 文件（瀑布流中没显示）</li>\n</ol>\n<p>要解决这个问题，首先从 @import 引入的谷歌字体 CSS 文件迁到 HTML 文档的 link 标签中。这从请求链中减少了一个链接。</p>\n<p>为了更快，可以直接将谷歌字体 CSS 文件内容插入 HTML 中，或应用的 CSS 文件中。</p>\n<p>有时无法消除请求链。在这种情况下，考虑使用预加载或预链接标签。例如，上面的网站可以在实际的 CSS 请求发生前先连接 fonts.googleapis.com。</p>\n<h4>重复利用服务器连接来加速请求</h4>\n<p>建立一个新的服务器连接通常需要在浏览器和服务器之间往返 3 次：</p>\n<ol>\n<li>DNS 检索</li>\n<li>建立 TCP 连接</li>\n<li>建立 SSL 连接</li>\n</ol>\n<p>一旦连接完成，在发送请求和下载响应时至少还需要一次或多次往返。</p>\n<p>下面瀑布流显示了创建了 4 个不同的连接：\nhostgator.com, optimizely.com, googletagmanager.com, and googelapis.com</p>\n<p>然而，随后在同一服务器的请求可以重新利用已经建立的连接。所以加载 base.css 或 index1.css 是很快的，因为它们也存在于 hostgator.com 上。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 583px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/78df7603c84c54788fbec82a7d0622c7/71275/hostgator-render-blocking.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.82332761578044%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABrElEQVQozzWRy47aQBRE+f+/ySrKIoskgplIgBgjP8FvG2ywsYM9foDJme5GLErqvi1VnVs98zyHoijo+56u65TkeRxHpmlSejweVHVNXVT8a3rqa0fbfNJcr3S3G0PTcD1n3O53Zv5+yeFwxHVdLMvCNE3CMCTLMsqy5HK5KPM4jQl0jzBrMcMjmrEhTVLaJOK+2TD++M4kPGauPScRD7vdDsMwlIIgECEHFeA4DlVVCaKGtvtk6HqqJkf3PrDdkHox5/96yfixYjrnzDznjThO2O/3ik7XdVVBmj5Dttstvu8rtU1LL2hP5xJjbhB6FhdHo7IMjsWBWzsJQmmYPA0lkSSU6ydiJk3kXEreW9HvUJwJVyuCP+/kf78RaW9EdkIUh4zl8CSUK8vVpJlpmMrY8zylF53stBGf9VkWVPqWsx9wCmxifYln7jmluahjkIQLtfKrQ03TiKJI9SZDpLnsNBEVDJ7LaFs8xPxS5vg/f5O/r0isX1hbhzzJmO3MhejroCikgW3b5HmuOnzRyYCj+KT7es1jtWRaLJh2Dl0S07VXjs4Sx7SpipovrCRI1KkJORwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"hostgator render blocking\"\n        title=\"hostgator render blocking\"\n        src=\"/static/78df7603c84c54788fbec82a7d0622c7/71275/hostgator-render-blocking.png\"\n        srcset=\"/static/78df7603c84c54788fbec82a7d0622c7/00d96/hostgator-render-blocking.png 148w,\n/static/78df7603c84c54788fbec82a7d0622c7/0b23c/hostgator-render-blocking.png 295w,\n/static/78df7603c84c54788fbec82a7d0622c7/71275/hostgator-render-blocking.png 583w\"\n        sizes=\"(max-width: 583px) 100vw, 583px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h4>减少文件大小并使用 CDN</h4>\n<p>除了文件大小，还有另外两个可控的因素会影响请求时间：资源的大小和服务器的路径。</p>\n<p>尽量发送小的数据给到用户，并保证它是压缩过的（通过 brotli 或 gzip）。</p>\n<p>内容分发网络是在各地提供了大量的服务器，其中某个服务器的位置可能是位于用户最近的地点。用户可以连接到距离他们更近的 CDN 服务器而不是网站的中心服务器。意味着服务器往返的时间会更少。对于一些静态的资源如 CSS，JavaScript 和图片是很方便的，因为它们容易部署。</p>\n<h4>通过 service worker 跳过网络请求</h4>\n<p>Service worker 允许在通过 network 发送之前劫持请求。意味着可以在初次请求过后存档资源文件。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c0c5b27bd4df5e42b3b8e57b2dfb02f2/77cf8/service-worker.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.19209039548023%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABaklEQVQozy1R25KjIBD1/z9ta2pqX2aSqUw0iaKIICDKJV7OttQ+dHXb58IBCy4khBwxKANtZ7wYR/VieDUdnlRcKDxrBqUNWi7QtD3qlmesJ93P/UFdYyStMg7FnwvDx03gp0+oNHDtPG5yw4U52kXc1Y7vxuHzxvPum834Wyp80e46JPzqHdV44Jd4l35D0fABrRhhl4T1ALTzmOMKOwfMYUWkpZ48pTAwhNklgg8aYrQIhKUNiNsBk3a4uKMoqxJd1yGGgHeKmCYL7xcoJfMcg8/z6/mEHIY8d10LawyC91kXiDMtC6xbULQtgzEWKSWqN0at4eYZ1lrM1EOMNE8YyMzQzjkH3gtIpcgoIsZERUHIfKJbFWV5z4Rt23AcB6XzeL/XbHYS13WlAw0YY7lncymx73vGTt1ZgcJ4eqqirmtUjweEENnsJGsSakpq/yc65/NZJGHjOKJuGrT0fWILXfU8XE8m/+l/+METOnGe9YIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"service worker\"\n        title=\"service worker\"\n        src=\"/static/c0c5b27bd4df5e42b3b8e57b2dfb02f2/799d3/service-worker.png\"\n        srcset=\"/static/c0c5b27bd4df5e42b3b8e57b2dfb02f2/00d96/service-worker.png 148w,\n/static/c0c5b27bd4df5e42b3b8e57b2dfb02f2/0b23c/service-worker.png 295w,\n/static/c0c5b27bd4df5e42b3b8e57b2dfb02f2/799d3/service-worker.png 590w,\n/static/c0c5b27bd4df5e42b3b8e57b2dfb02f2/77cf8/service-worker.png 708w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>当然，仅当不需要网络发送响应时，此方法才会有效。用户需要缓存过响应内容，在第二次加载应用时才会有更好的体验。</p>\n<p>下面的 service worker 缓存了渲染页面所需的 HTML 和 CSS。当应用再次加载时，它会尝试去提供缓存过的资源，并在不可用时会回退至网络请求。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">self<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'install'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">async</span> <span class=\"token parameter\">e</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  caches<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'v1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cache</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'/app'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'/app.css'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fetch'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span>\n    caches<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cachedResponse</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> cachedResponse <span class=\"token operator\">||</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>查看更多关于<a href=\"https://developers.google.com/web/ilt/pwa/caching-files-with-service-worker\">通过 service worker 预加载和缓存资源</a>。</p>","frontmatter":{"title":"高性能前端架构","date":"March 12, 2020","description":"本文将从几个方面来介绍如何构建高性能架构"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tags":["Architecture","Performance"],"slug":"/performant-frontend-architecture/","previous":null,"next":{"excerpt":"背景 我之前每天都会去腾讯新闻页面上去关注有关疫情发展的当日的数据状况，久而久之就感觉该页面不够精简，而且路径过长，需要二次点击才能看到主页面。那么就干脆直接去拿他们的数据来自己做个页面好了，仓库地址：前端https://github.com/keisei77/small…","fields":{"slug":"/build-crawler-with-nextjs-and-heroku/"},"frontmatter":{"date":"March 08, 2020","description":"了解如何利用免费资源来实现微型爬虫 Web 应用并记录遇到的一些坑","title":"使用 Next.js + Puppeteer + heroku 构建爬虫 Web APP","tags":["Crawler","Next.js","Puppeteer"]}}}}}